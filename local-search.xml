<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>听力日常-10-12</title>
    <link href="/blog.github.io/2023/10/12/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-12/"/>
    <url>/blog.github.io/2023/10/12/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-12/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-12</h1><h2 id="U校园-U2-Outside-view">U校园 U2  Outside view</h2><h3 id="Outside-view">Outside view</h3><p>今天应该是在教室里听一会儿，回宿舍再听一会儿，搞了差不多五个小时的小程序，还是没忍住玩了五个小时的手机，感觉是中午吃饭和晚上吃饭的时候玩的多，还有就是睡前，上床的时候把手机放在桌子上还是有效果的 😩。</p><h4 id="Conversation1">Conversation1</h4><h5 id="生单词">生单词</h5><p><code>UNICEF</code> ：联合国儿童基金会</p><p><code>Kabul</code> ：阿富汗首都喀布尔</p><p><code>Taliban</code> ：塔利班</p><p><code>agency</code> : (听到的但是不知道意思) 代理机构</p><p><code>malnutrition</code> ：营养不良的</p><p>按住剋神 ：<code>education</code></p><p><code>kids</code> 不是 <code>keys</code></p><p><code>medicine</code> ：打错了</p><p><code>known</code> 不是 <code>know</code></p><hr><h4 id="Conversation2">Conversation2</h4><h5 id="生单词-v2">生单词</h5><p><code>presenter</code> ：主持人</p><p><code>engineers</code> : 工程师</p><p><code>notebook</code> 不是<code>no books</code></p><p>夫人四年饭盒热 ：<code>friends and fun here</code></p><p><code>train teachers</code> 不是 <code>try teachers</code></p><p><code>supplies</code> ：供应</p><p><code>enrolle</code> ：注册</p><hr><h3 id="Listening-in">Listening in</h3><h4 id="News-reports">News reports</h4><h5 id="第一篇">第一篇</h5><h6 id="生单词-v3">生单词</h6><p><code>relive</code>  ： 重新经历</p><p><code>viral</code> : 病毒的</p><p><code>go viral </code> ：在互联网走红</p><p><code>selfie</code> ：自拍</p><p><code>beloved</code> ：敬爱的</p><hr><h5 id="第二篇">第二篇</h5><h6 id="生单词-v4">生单词</h6><p><code>rare</code> :  罕见的稀有的</p><p><code>figurine</code> ：人像</p><p><code>nostaigia</code> ：怀旧</p><p><code>recapture</code> ：夺回</p><hr><h3 id="学习时长">学习时长</h3><p><img src="https://ooo.0x0.ooo/2023/10/12/O1jbvx.jpg" alt="O1jbvx.jpg"></p><p>感觉今天的差不多听个两三遍都能听懂个百分之七八十，除去一些小单词和语句的意思确实理解错之外。</p><p>差不多听了一个多小时，<code>Listening in</code> 还是差一点，唉唉唉、困困困  😪 😪 😪 ，真希望有一天能睡24个小时。提交完这个还有一个力扣题没写完… 补一补写完再睡吧。反正明天没有早八…。</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-11</title>
    <link href="/blog.github.io/2023/10/11/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-11/"/>
    <url>/blog.github.io/2023/10/11/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-11/</url>
    
    <content type="html"><![CDATA[<p>英语记录</p><h1>2023-10-11</h1><h2 id="U校园-U2-Inside-view">U校园 U2  Inside view</h2><h3 id="Inside-view">Inside view</h3><h4 id="Conversation1">Conversation1</h4><h5 id="生单词">生单词</h5><p><code>dock</code> ：船坞、修船所</p><p><code>ship</code> : 船</p><p><code>go up</code> ：上升</p><p><code>pollute</code> ：污染</p><p><code>cargo</code> ：货物</p><p><code>trendy</code> ：时髦</p><p><code>distinctive</code> ：与众不同的</p><p><code>revolting</code> ：令人作呕的</p><p><code>warehouse</code> : 货舱</p><hr><h4 id="Conversation2">Conversation2</h4><h5 id="生单词-v2">生单词</h5><p><code>studio</code> :工作室</p><p><code>Back in a minute </code> ：马上回来</p><p><code>pround of you </code> ：为你骄傲  （填错的）</p><p><code>Hang on</code> : 稍等一下</p><hr><p>本来想着今天把 <code>OutSide view</code> 也听完，但是太困了…😴 🛌 😪</p><p>就只能听完这些了… 😭 😭</p><p>希望明天能把 <code>OutSide view</code> 和<code>Listening in</code> 听完，之后搞份六级听听 :happy:  。</p><h3 id="学习时长">学习时长</h3><p><img src="https://ooo.0x0.ooo/2023/10/11/O1sPPG.jpg" alt="O1sPPG.jpg"></p><p><code>Conversation1</code> 有点听不懂，所以听了好几遍，听懂了之后再去做后边的就很快了。</p><p><code>Conversation2</code> 听得懂，虽然不是每个单词都听到，但是能把意思听懂的，所以就听的时间短了一点。</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10月上半月汇总</title>
    <link href="/blog.github.io/2023/10/11/10%E6%9C%88%E4%B8%8A%E5%8D%8A%E6%9C%88%E6%B1%87%E6%80%BB/"/>
    <url>/blog.github.io/2023/10/11/10%E6%9C%88%E4%B8%8A%E5%8D%8A%E6%9C%88%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>时隔将近半个月又开始写博客了，这半个月倒是经历了挺多的事情。</p><h4 id="1：数学建模国赛出成绩了—省一">1：数学建模国赛出成绩了—省一</h4><p>结果确实是没想到，不仅没想到还有点意外，论文的完整性确实有的。但是论文的算法确实不多，仅仅的包括了数学规划、聚类模型、OLS最小二乘法。这个成绩很意外的，因为一般数模竞赛需要三个人，我们这次基本我负责的是编程和建模、另一个数学专业的学姐负责的是写论文，其余的那个人（隐身了…）。</p><p>自己在这几天其实做的也不算好，每日最爱干的事情还是睡觉…，建模也没建的多好。没做好的原因可以很坦诚地说，原因是因为自己一开始也没想着能得奖…，唉，如果当初花时间做一下相关性分析，把论文的进一步完整性提高上去就好了。不过后悔也没用了</p><p>但是结果确实很意外，下次参加美赛的时候一定要把握好机会，不要浪费时间，We are all dying！希望美赛能获得M奖吧。</p><h4 id="2：微信小程序开发—还差一部分">2：微信小程序开发—还差一部分</h4><p>一个国庆，整整一个国庆，基本处于一种近乎癫狂的状态，一直在做…，不过好在现在做的差不多了（还差一些关键的部分）。</p><p>这部分的感触很深的事情就是，不要一直把事情放脑子里，应该做下去而不是只是在脑子里构想，有一些事情开始做才会有效，一直在脑子里想是没有用处的。</p><hr><h3 id="下半个月的计划">下半个月的计划</h3><p>很重要的一件事，希望能把每日使用手机的时间降到2小时</p><table><thead><tr><th>事情</th><th>记录状况</th></tr></thead><tbody><tr><td>操作系统</td><td>希望能把rust学完，博客记录</td></tr><tr><td>计算机网络</td><td>上这个课的时候不要睡觉吧，能跟上就好。</td></tr><tr><td>英语方面</td><td>希望每天能写一个博客记录英语学习状况</td></tr><tr><td>算法方面</td><td>希望这十五天之后能把leetcode刷到100题</td></tr><tr><td>数据库方面</td><td>希望能刷20-30道SQL语句</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>半月汇总</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode2tree</title>
    <link href="/blog.github.io/2023/09/29/leetcode2tree/"/>
    <url>/blog.github.io/2023/09/29/leetcode2tree/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ： 二叉树的简单题</p><ol><li><h2 id="94-二叉树的中序遍历-力扣（LeetCode）"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/?envType=study-plan-v2&amp;envId=top-100-liked">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></h2></li></ol><p>题目 ：给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em></p><p>输入 ： <img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom:80%;"></p><p>输入  ：<code>root = [1,null,2,3]</code></p><p>输出 ：  <code>[1,3,2]</code></p><p>代码 ：中序遍历，左子树根右子树，用递归即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindAns</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br>       <span class="hljs-comment">//root为空</span><br>       <span class="hljs-keyword">if</span>(root)&#123;<br>           <span class="hljs-built_in">FindAns</span>(root-&gt;left);<br>           ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>           <span class="hljs-built_in">FindAns</span>(root-&gt;right);<br>       &#125;<br>   &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>      <span class="hljs-built_in">FindAns</span>(root);<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><h2 id="104-二叉树的最大深度-力扣（LeetCode）"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&amp;envId=top-100-liked">104. 二叉树的最大深度 - 力扣（LeetCode）</a></h2></li></ol><p>题目 ： 给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img" style="zoom:80%;"><p>输入 ： <code>root = [3,9,20,null,null,15,7]</code></p><p>输出 ： <code>3</code></p><p>代码 ：当前二叉树的深度等于左子树的深度和右子树的深度的最大值加一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">depth</span>(root-&gt;left),<span class="hljs-built_in">depth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">depth</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li><h2 id="226-翻转二叉树-力扣（LeetCode）"><a href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&amp;envId=top-100-liked">226. 翻转二叉树 - 力扣（LeetCode）</a></h2></li></ol><p>题目 ： 给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" style="zoom:80%;"><p>输入 ： <code>root = [4,2,7,1,3,6,9]</code></p><p>输出 ： <code>[4,7,2,9,6,3,1]</code></p><p>代码  ： 从二叉树的上至下利用中间值t进行递归翻转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root)&#123;<br>            TreeNode *t=root-&gt;left;<br>            root-&gt;left=root-&gt;right;<br>            root-&gt;right=t;<br>            <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>            <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode121</title>
    <link href="/blog.github.io/2023/09/29/leetcode121/"/>
    <url>/blog.github.io/2023/09/29/leetcode121/</url>
    
    <content type="html"><![CDATA[<p>题目来源  ： <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?envType=study-plan-v2&amp;envId=top-100-liked">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p><p>题目 ： 给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code></p><p>输入 ： <code>[7,1,5,3,6,4]</code></p><p>输出  :  <code>5</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>       <span class="hljs-comment">//如果股票在第i天卖出，则一定会在第i天之前的价格最少的一天卖出</span><br>       <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> min=<span class="hljs-number">10001</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>           <span class="hljs-keyword">if</span>(min&gt;prices[i])&#123;<br>               min=prices[i];<br>           &#125;<br>           <span class="hljs-keyword">if</span>(ans&lt;(prices[i]-min))&#123;<br>               ans=(prices[i]-min);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>思路就是利用贪心的思想，如果股票在第 <code>i</code> 天卖出，那么可以肯定的是股票购买的价格一定是第 <code>i</code> 天以前的价格最低的那天，所以通过一层循环，既可以得出答案。在循环的过程中不断进行更新最小的价格和答案。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode605</title>
    <link href="/blog.github.io/2023/09/29/leetcode605/"/>
    <url>/blog.github.io/2023/09/29/leetcode605/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/can-place-flowers/">605. 种花问题 - 力扣（LeetCode）</a></p><p style="color :red;">难度 ： 简单 </p><p>题目 ： 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p><p>输入 ： <code>flowerbed = [1,0,0,0,1], n = 1</code></p><p>输出  ： <code>true</code></p><p>代码 ：</p><p>先对花园的<code>首</code> 、<code>尾</code> 进行判断，之后在内部数0的个数，如果两个<code>1</code> 之间是奇数个<code>0</code> 那么就是<code>count/2</code> 如果是偶数个<code>0</code> 那么就是 <code>count/2-1</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> start = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; flowerbed[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>            n -= <span class="hljs-number">1</span>;<br>            flowerbed[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flowerbed.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; flowerbed[flowerbed.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[flowerbed.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>] == <span class="hljs-number">0</span>) &#123;<br>            n -= <span class="hljs-number">1</span>;<br>            flowerbed[flowerbed.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flowerbed.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; n == <span class="hljs-number">1</span>) || n == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; flowerbed.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (flowerbed[i] == <span class="hljs-number">1</span> &amp;&amp; start == <span class="hljs-literal">false</span>) &#123;<br>                count = <span class="hljs-number">0</span>;<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flowerbed[i] == <span class="hljs-number">0</span>&amp;&amp;start==<span class="hljs-literal">true</span>) &#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flowerbed[i] == <span class="hljs-number">1</span> &amp;&amp; start == <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                        n -= (count / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        n -= (count / <span class="hljs-number">2</span>);<br>                    &#125;<br>                &#125;<br>                start = <span class="hljs-literal">false</span>;<br>                i -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode15</title>
    <link href="/blog.github.io/2023/09/28/leetcode15/"/>
    <url>/blog.github.io/2023/09/28/leetcode15/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ： <a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&amp;envId=top-100-liked">15. 三数之和 - 力扣（LeetCode）</a></p><p style="color :red"> 难度 ： 中等 </p><p>题目 ： 给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><p>输入 : <code>nums = [-1,0,1,2,-1,-4]</code></p><p>输出 ： <code>[[-1,-1,2],[-1,0,1]]</code></p><p>思路 ：因为昨天做了个用双指针的水桶的题，所以做这个题一开始也想直接用双指怎。先对数组进行排序，之后利用一个指针i指向的是开始、指针j指向的是末尾。利用指针k进行遍历中间的元素也就是双层循环就可以，但是逻辑是有漏洞的因为当<code>nums[i]+nums[j]+nums[k]=0</code> 的时候你是不知道应该怎么移动指针的。所以需要更改代码。改来改去感觉这个思路不太对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//漏洞代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;,<span class="hljs-type">int</span>&gt;HashTable;    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//按照惯例先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; t;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>            <span class="hljs-type">int</span> a = nums[i] + nums[j];<br>            t.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; k &lt;= j - <span class="hljs-number">1</span>; k++) &#123;<br>                <span class="hljs-keyword">if</span> ((a + nums[k]) == <span class="hljs-number">0</span>) &#123;<br>                    t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                    t.<span class="hljs-built_in">push_back</span>(nums[j]);<br>                    t.<span class="hljs-built_in">push_back</span>(nums[k]);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-keyword">if</span>(HashTable[t]!=<span class="hljs-number">1</span>)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(t);<br>                    HashTable[t]=<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">//这里是不对的。</span><br>                i++;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//没问题</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) &#123;<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    j--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>于是重新想了一个思路，两个数相加等于0不就说明，其中的两个数相加等于另外一个数的相反数。改啊改啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt;HashTable;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//按照惯例先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//外层循环</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        vector&lt;<span class="hljs-type">int</span>&gt; t;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            t.<span class="hljs-built_in">clear</span>();<br>            t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-type">int</span> a = nums[i];<br>            j = i + <span class="hljs-number">1</span>;<br>            k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                b = nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (b + a == <span class="hljs-number">0</span> &amp;&amp; j != i &amp;&amp; k != i) &#123;<br>                    t.<span class="hljs-built_in">push_back</span>(nums[j]);<br>                    t.<span class="hljs-built_in">push_back</span>(nums[k]);<br>                    j = i + <span class="hljs-number">1</span>;<br>                    k--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (b + a &lt; <span class="hljs-number">0</span>) &#123;<br>                        j++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        k--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>                <span class="hljs-keyword">if</span> (HashTable[t] != <span class="hljs-number">1</span> &amp;&amp; t.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(t);<br>                    HashTable[t] = <span class="hljs-number">1</span>;<br>                    t.<span class="hljs-built_in">clear</span>();<br>                    t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;<br>                    t.<span class="hljs-built_in">clear</span>();<br>                    t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>最后在300个测试样例的时候超时了，真是遗憾啊，差一点就过了…。</p><p>继续改啊改啊，终于过了…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt;HashTable;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//按照惯例先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//外层循环</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        vector&lt;<span class="hljs-type">int</span>&gt; t;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            t.<span class="hljs-built_in">clear</span>();<br>            t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-type">int</span> a = nums[i];<br>            j = i + <span class="hljs-number">1</span>;<br>            k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                b = nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (b + a == <span class="hljs-number">0</span> &amp;&amp; j != i &amp;&amp; k != i) &#123;<br>                    t.<span class="hljs-built_in">push_back</span>(nums[j]);<br>                    t.<span class="hljs-built_in">push_back</span>(nums[k]);<br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-type">int</span> l=nums[j];<br>                    <span class="hljs-keyword">while</span>(nums[j]==k)&#123;<br>                        j++;<br>                    &#125;<br>                    k--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (b + a &lt; <span class="hljs-number">0</span>) &#123;<br>                        j++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        k--;<br>                    &#125;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">size</span>()==<span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>                    <span class="hljs-keyword">if</span>(HashTable[t]!=<span class="hljs-number">1</span>)&#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(t);<br>                        HashTable[t]=<span class="hljs-number">1</span>;<br>                    &#125;<br>                    t.<span class="hljs-built_in">clear</span>();<br>                    t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>因为今天去看了奥本海默所以只做这么一道题吧…</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode1333</title>
    <link href="/blog.github.io/2023/09/27/leetcode1333/"/>
    <url>/blog.github.io/2023/09/27/leetcode1333/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ： <a href="https://leetcode.cn/problems/filter-restaurants-by-vegan-friendly-price-and-distance/description/?envType=daily-question&amp;envId=2023-09-27">1333. 餐厅过滤器 - 力扣（LeetCode）</a></p><p style="color :red"> 难度 ：中等 </p><p>题目 ：给你一个餐馆信息数组 <code>restaurants</code>，其中 <code>restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]</code>。你必须使用以下三个过滤器来过滤这些餐馆信息。</p><p>其中素食者友好过滤器 <code>veganFriendly</code> 的值可以为 <code>true</code> 或者 <code>false</code>，如果为 <em>true</em> 就意味着你应该只包括 <code>veganFriendlyi</code> 为 true 的餐馆，为 <em>false</em> 则意味着可以包括任何餐馆。此外，我们还有最大价格 <code>maxPrice</code> 和最大距离 <code>maxDistance</code> 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。</p><p>过滤后返回餐馆的 *<strong>id*</strong>，按照 <em><strong>rating</strong></em> 从高到低排序。如果 <em><strong>rating</strong></em> 相同，那么按 <em><strong>id</strong></em> 从高到低排序。简单起见， <code>veganFriendlyi</code> 和 <code>veganFriendly</code> 为 <em>true</em> 时取值为 <em>1</em>，为 <em>false</em> 时，取值为 <em>0 。</em></p><p>输入：<code>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10</code><br>输出：<code>[3,1,5] </code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//需要注意这里的类型需要是static</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,vector&lt;<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]&gt;b[<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]==b[<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">filterRestaurants</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; restaurants, <span class="hljs-type">int</span> veganFriendly, <span class="hljs-type">int</span> maxPrice, <span class="hljs-type">int</span> maxDistance)</span> </span>&#123;<br>        <span class="hljs-comment">//先进行排序</span><br>        <span class="hljs-built_in">sort</span>(restaurants.<span class="hljs-built_in">begin</span>(),restaurants.<span class="hljs-built_in">end</span>(),cmp);<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>          vector&lt;<span class="hljs-type">int</span>&gt; t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;restaurants.<span class="hljs-built_in">size</span>();i++)&#123;<br>            t=restaurants[i];<br>            <span class="hljs-keyword">if</span>(veganFriendly==<span class="hljs-number">1</span>)&#123;<br>                 <span class="hljs-keyword">if</span>(t[<span class="hljs-number">2</span>]==veganFriendly&amp;&amp;t[<span class="hljs-number">3</span>]&lt;=maxPrice&amp;&amp;t[<span class="hljs-number">4</span>]&lt;=maxDistance)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(t[<span class="hljs-number">0</span>]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                 <span class="hljs-keyword">if</span>(t[<span class="hljs-number">3</span>]&lt;=maxPrice&amp;&amp;t[<span class="hljs-number">4</span>]&lt;=maxDistance)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(t[<span class="hljs-number">0</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先排序，再遍历找满足条件的即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode11</title>
    <link href="/blog.github.io/2023/09/27/leetcode11/"/>
    <url>/blog.github.io/2023/09/27/leetcode11/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a><br>题目 ：给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>**说明：**你不能倾斜容器。</p><p>输入 ： <code>[1,8,6,2,5,4,8,3,7]</code></p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" style="zoom:80%;"><p>输出 ： <code>49</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;height.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(ans&lt;(<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i)))&#123;<br>                    ans=(<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一开始第一眼，确实想到了直接套两层循环就直接得出结果了。但是结果确实可想而知，超出时间限制了…</p><img src="https://img1.imgtp.com/2023/09/27/23EdrEv3.jpg" alt="leetcode11outtime.jpg" style="zoom:80%;"><p>继续优化呀，优化呀…</p><p>想啊，想啊，想啊，一根烟，一瓶水，一道力扣想一天…。</p><p>终于看了K神的题解，原来用双指针就可以解决这个问题…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i!=j)&#123;<br>            <span class="hljs-keyword">if</span>(ans&lt;(<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i)))&#123;<br>                ans=<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(height[i]&lt;height[j])&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>        &#125;<br>          <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode142</title>
    <link href="/blog.github.io/2023/09/27/leetcode142/"/>
    <url>/blog.github.io/2023/09/27/leetcode142/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&amp;envId=top-100-liked">142. 环形链表 II - 力扣（LeetCode）</a></p><p>题目 ：给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。<strong>不允许修改</strong> 链表。</p><p>输入 ： <code>head = [3,2,0,-4], pos = 1</code></p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:80%;"><p>输出 ： <code>返回索引为 1 的链表节点</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;ListNode *,<span class="hljs-type">int</span>&gt; HashTable;<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *p1=head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(HashTable[p1]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> p1;<br>                &#125;<br>                HashTable[p1]=<span class="hljs-number">1</span>;<br>                p1=p1-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>继续使用哈希表…</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode141</title>
    <link href="/blog.github.io/2023/09/26/leetcode141/"/>
    <url>/blog.github.io/2023/09/26/leetcode141/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ： <a href="https://leetcode.cn/problems/linked-list-cycle/?envType=study-plan-v2&amp;envId=top-100-liked">141. 环形链表 - 力扣（LeetCode）</a></p><p>题目 ： 给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p>输入 ： <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:80%;"></p><p><code>head = [3,2,0,-4], pos = 1</code></p><p>输出 <code>true</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;ListNode *,<span class="hljs-type">int</span>&gt; HashTable;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *p1=head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(HashTable[p1]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                HashTable[p1]=<span class="hljs-number">1</span>;<br>                p1=p1-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用哈希表…哈希表真是个好东西！</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode169</title>
    <link href="/blog.github.io/2023/09/26/leetcode169/"/>
    <url>/blog.github.io/2023/09/26/leetcode169/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：</p><p style="color :red;">难度 ：简单</p><p>题目 ： 给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>输入 ：<code>nums = [3,2,3]</code></p><p>输出：<code>3</code></p><p>思路 1：利用哈希表即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//用哈希表</span><br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;HashTable;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            HashTable[nums[i]]++;<br>            <span class="hljs-keyword">if</span>(HashTable[nums[i]]&gt;nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode206</title>
    <link href="/blog.github.io/2023/09/26/leetcode206/"/>
    <url>/blog.github.io/2023/09/26/leetcode206/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：</p><p style="color :red;">难度 ：简单</p><p>题目 ：给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" style="zoom: 80%;"><p>输入 ：<code>head = [1,2,3,4,5]</code></p><p>输出：<code>[5,4,3,2,1]</code></p><p>思路 1：用三个指向链表的指针即可以完成这个过程。但是代码出现一个问题，很奇怪的问题。循环结束之后<code>p</code>指向的是倒数第二个节点，<code>q</code> 指向的是最后一个结点，但是我发现如果直接将 <code>q-&gt;next=p</code> 会出错。想到为什么会出错了，因为如果针对的是两个结点的链表将<code>p-&gt;next=q</code>那么会造成一个循环链表这样一定会出现错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//链表反转</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;next-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            ListNode *p=head;<br>            ListNode *q=p-&gt;next;<br>            ListNode *t =q-&gt;next;<br>            <span class="hljs-keyword">while</span>(t)&#123;<br>                <span class="hljs-keyword">if</span>(p==head)&#123;<br>                    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>                &#125;<br>                q-&gt;next=p;<br>                p=q;<br>                q=t;<br>                t=t-&gt;next;<br>            &#125;<br>            ListNode *ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>            ans-&gt;val=q-&gt;val;<br>            ans-&gt;next=p;<br>            <span class="hljs-keyword">return</span>  ans;<br>        &#125; <br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> val=head-&gt;next-&gt;val;<br>            head-&gt;next-&gt;val=head-&gt;val;<br>            head-&gt;val=val;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>改进版代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 链表反转</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 空链表或只有一个节点，无需反转</span><br>        &#125;<br><br>        ListNode *prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode *current = head;<br>        <br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode *nextNode = current-&gt;next;<br>            current-&gt;next = prev;<br>            prev = current;<br>            current = nextNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev; <span class="hljs-comment">// prev 指向新的链表头</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode160</title>
    <link href="/blog.github.io/2023/09/26/leetcode160/"/>
    <url>/blog.github.io/2023/09/26/leetcode160/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&amp;envId=top-100-liked">160. 相交链表 - 力扣（LeetCode）</a></p><p style="color :red;">难度 ：简单</p><p>题目 ： 给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="160_statement.png (742×241) (leetcode-cn.com)" style="zoom:80%;"><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p>输入 ：<code>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</code></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img" style="zoom:80%;"></a></p><p>输出：<code>Intersected at '8'</code></p><p>思路 ：这个题是很简单的，直接对两个链表进行遍历，找到相等的点即可。但是一开始确实一直出错，请看代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *p=headA;<br>        ListNode *q=headB;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>)&#123;<br>            q=headB;<br>            <span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">if</span>(p==q)&#123;<br>                    <span class="hljs-keyword">return</span> p;<br>                &#125;<br>                q=q-&gt;next;<br>            &#125;<br>            p=p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>不知道你们看出来没有，其实错误点在于第一层循环居然用的两个链表都是非空的情形，这这个错误导致最后只进行了一层循环。</p><p>改成 <code>while(p!=NULL)</code>即可。</p><p>代码 2： 其实这个也是按照于链表的遍历，但是相较于第一种偏向于同时进行循环遍历，即不再是嵌套循环而是<code>两个圈子一起循环</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *p1 = headA;<br>        ListNode *p2 = headB;<br>        <span class="hljs-comment">// 遍历链表直到相交或同时到达末尾</span><br>        <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>            p1 = (p1 != <span class="hljs-literal">NULL</span>) ? p1-&gt;next : headB;<br>            p2 = (p2 != <span class="hljs-literal">NULL</span>) ? p2-&gt;next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1; <span class="hljs-comment">// 返回交点或NULL</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode128</title>
    <link href="/blog.github.io/2023/09/24/leetcode128/"/>
    <url>/blog.github.io/2023/09/24/leetcode128/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&amp;envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p><p style="color :red"> 难度 ：中等</p><p>题目 ： 给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p>输入 ： <code>nums = [100,4,200,1,3,2]</code></p><p>输出 ： <code>4</code></p><p>解释 ： <code>最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//去重代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;HashTable;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//去重</span><br>       vector&lt;<span class="hljs-type">int</span>&gt; t;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>           <span class="hljs-keyword">if</span>(HashTable[nums[i]]!=<span class="hljs-number">1</span>)&#123;<br>               t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>           &#125;<br>           HashTable[nums[i]]=<span class="hljs-number">1</span>;<br>       &#125;<br>        nums=t;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]+<span class="hljs-number">1</span>==nums[i+<span class="hljs-number">1</span>])&#123;<br>                ans++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(max&lt;ans)&#123;<br>                    max=ans;<br>                &#125;<br>                ans=<span class="hljs-number">0</span>;<br>            &#125; <br>        &#125;<br>        max=max&gt;ans?max:ans;<br>        <span class="hljs-keyword">return</span> max+<span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//不去重代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;HashTable;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]+<span class="hljs-number">1</span>==nums[i+<span class="hljs-number">1</span>])&#123;<br>                ans++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]==nums[i+<span class="hljs-number">1</span>])&#123;<br>                ans=ans;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(max&lt;ans)&#123;<br>                    max=ans;<br>                &#125;<br>                ans=<span class="hljs-number">0</span>;<br>            &#125; <br>        &#125;<br>        max=max&gt;ans?max:ans;<br>        <span class="hljs-keyword">return</span> max+<span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路 ：先利用<code>sort</code> 函数进行排序，之后利用<code>HashTable</code> 来去重，之后遍历查找最大的即可。还可以不去重，则在遍历的时候判断是否存在重的可能。</p><img src="https://img1.imgtp.com/2023/09/24/1fzaDTMt.png" alt="leetcode128ac.png" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode49</title>
    <link href="/blog.github.io/2023/09/24/leetcode49/"/>
    <url>/blog.github.io/2023/09/24/leetcode49/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&amp;envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p><p style="color :red;">难度 ： 中等</p><p>题目 :给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p>输入: <code>strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code></p><p>输出:<code>[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</code></p><p>代码:</p><p style="color :red">代码1</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;string ,<span class="hljs-type">int</span>&gt; HashTable;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>      vector&lt;string&gt; tt;<br>      vector&lt;string&gt; t;<br>      vector&lt;vector&lt;string&gt;&gt; ans;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.<span class="hljs-built_in">size</span>();i++)&#123;<br>          tt.<span class="hljs-built_in">push_back</span>(strs[i]);<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tt.<span class="hljs-built_in">size</span>();i++)&#123;<br>          <span class="hljs-built_in">sort</span>(tt[i].<span class="hljs-built_in">begin</span>(),tt[i].<span class="hljs-built_in">end</span>());<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tt.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(tt[i]!=<span class="hljs-string">&quot;A&quot;</span>)&#123;<br>                HashTable.<span class="hljs-built_in">clear</span>();<br>                HashTable[tt[i]]=<span class="hljs-number">1</span>;<br>                t.<span class="hljs-built_in">clear</span>();<br>                t.<span class="hljs-built_in">push_back</span>(strs[i]);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;tt.<span class="hljs-built_in">size</span>();j++)&#123;<br>                    <span class="hljs-keyword">if</span>(HashTable[tt[j]]==<span class="hljs-number">1</span>)&#123;<br>                        t.<span class="hljs-built_in">push_back</span>(strs[j]);<br>                        tt[j]=<span class="hljs-string">&quot;A&quot;</span>;<br>                    &#125;<br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(t);<br>            &#125;   <br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路1 :利用哈希表和一个辅助的 <code>string</code> 数组 <code>tt</code>，<code>tt</code>用来存储的是字母已经被排过顺序的字符串数组。其中利用<code>tt</code> 来构建哈希表，之后通过哈希表和双层循环来找出一组<strong>字母异位词</strong>的数组。但是因为时间复杂度太高，导致并没有通过<code>leetcode</code>。</p><img src="https://img1.imgtp.com/2023/09/24/BRg0FSpR.png" alt="leetcode49outtimepng.png" style="zoom: 67%;"><p style="color :blue;">代码2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;string ,<span class="hljs-type">int</span>&gt; HashTable;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>      vector&lt;string&gt; tt;<br>      vector&lt;string&gt; t;<br>      vector&lt;vector&lt;string&gt;&gt; ans;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.<span class="hljs-built_in">size</span>();i++)&#123;<br>          tt.<span class="hljs-built_in">push_back</span>(strs[i]);<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tt.<span class="hljs-built_in">size</span>();i++)&#123;<br>          <span class="hljs-built_in">sort</span>(tt[i].<span class="hljs-built_in">begin</span>(),tt[i].<span class="hljs-built_in">end</span>());<br>      &#125;<br>      vector&lt;string&gt;::iterator to;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tt.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(tt[i]!=<span class="hljs-string">&quot;A&quot;</span>)&#123;<br>                t.<span class="hljs-built_in">clear</span>();<br>                t.<span class="hljs-built_in">push_back</span>(strs[i]);<br>                to=tt.<span class="hljs-built_in">begin</span>();<br>                string a=tt[i];<br>                tt[i]=<span class="hljs-string">&quot;A&quot;</span>;<br>                <span class="hljs-keyword">while</span>(to!=tt.<span class="hljs-built_in">end</span>())&#123;<br>                    to=<span class="hljs-built_in">find</span>(tt.<span class="hljs-built_in">begin</span>(),tt.<span class="hljs-built_in">end</span>(),a);<br>                    <span class="hljs-keyword">if</span>(to!=tt.<span class="hljs-built_in">end</span>())&#123;<br>                        t.<span class="hljs-built_in">push_back</span>(strs[to-tt.<span class="hljs-built_in">begin</span>()]);<br>                        *to=<span class="hljs-string">&quot;A&quot;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(t);<br>            &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路2 :利用<code>vector</code> 的<code>find</code> 函数减少一些运算。</p><img src="https://img1.imgtp.com/2023/09/24/6Uljzvd8.png" alt="leetcode49ac.png" style="zoom: 80%;">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode136</title>
    <link href="/blog.github.io/2023/09/23/leetcode136/"/>
    <url>/blog.github.io/2023/09/23/leetcode136/</url>
    
    <content type="html"><![CDATA[<p>题目来源  ： <a href="https://leetcode.cn/problems/single-number/?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><p style="color :red;">难度 ：简单</p><p>题目 ：给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>输入 ： <code>nums = [2,2,1]</code></p><p>输出 ： <code>1</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; HashTable;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            HashTable[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(HashTable[nums[i]]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路 ：</p><p>利用哈希表，时间复杂度<code>O(n)</code> 空间复杂度 <code>O(n)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVST</title>
    <link href="/blog.github.io/2023/09/23/CVST/"/>
    <url>/blog.github.io/2023/09/23/CVST/</url>
    
    <content type="html"><![CDATA[<h1>MATLAB 计算机视觉实战</h1><p>这是一本由 赵小川、何灏、唐弘毅 编著的一本关于MATLAB计算机视觉实战的一本书。</p><p>由清华大学出版社出版，售价49元</p><p>从MATLAB基础和数字图像处理开始，基于系统对象的编程、模块化仿真、C/C++代码生成、双目立体视觉及其程序实现。</p><h2 id="第一章MATLAB操作基础">第一章MATLAB操作基础</h2><h3 id="1-1矩阵操作与运算">1.1矩阵操作与运算</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%%行向量、列向量、矩阵</span><br>a=[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] <span class="hljs-comment">%a=[1,2,3]</span><br>a=<br>[<span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span>]<br><span class="hljs-comment">%a=[1;2;3]</span><br>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<span class="hljs-comment">%a=[1 2 3;4 5 6;7 8 9]</span><br><br><span class="hljs-comment">%%特殊矩阵的生成函数</span><br><span class="hljs-built_in">ones</span>(n) <span class="hljs-comment">%生成n*n的全1矩阵</span><br><span class="hljs-built_in">ones</span>(m,n,....p)<span class="hljs-comment">%生成n*m*...*p的全1矩阵</span><br><span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(A))<span class="hljs-comment">%生成一个与矩阵A同样大小的全1矩阵</span><br><span class="hljs-built_in">zeros</span>(n) <span class="hljs-comment">%生成n*n的全0矩阵</span><br><span class="hljs-built_in">zeros</span>(n,m,.....p)<span class="hljs-comment">%生成n*m*...*p的全0矩阵</span><br><span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(A))<span class="hljs-comment">%生成与A大小相同的全0元素矩阵</span><br><span class="hljs-built_in">eye</span>(n) <span class="hljs-comment">%创建一个大小为n*n的单位矩阵</span><br><span class="hljs-built_in">eye</span>(n,m...p)<span class="hljs-comment">%创建一个大小为n*m*....*p的单位矩阵</span><br><span class="hljs-built_in">eye</span>(<span class="hljs-built_in">size</span>(A))<span class="hljs-comment">%创建一个大小与A同样的单位矩阵</span><br><span class="hljs-built_in">magic</span>(n) <span class="hljs-comment">%生成的每一行，每一列的和都相等</span><br><span class="hljs-built_in">rand</span>(n)<span class="hljs-comment">%生成一个n*n的正态分布随机矩阵，其元素均为0均值，单位方差的正态分布的随机数</span><br><span class="hljs-built_in">rand</span>(n)<span class="hljs-comment">%生成的为随机数矩阵，其元素为0-1的均有分布</span><br><span class="hljs-built_in">diag</span>(x)<span class="hljs-comment">%创建一个n维的对角仿真，主对角线取值为向量x，其余元素均为0</span><br><span class="hljs-built_in">triu</span>(A) <span class="hljs-comment">%创建一个与矩阵A大小相同的上三角矩阵，其中的主对角线元素为A上的对应的元素。</span><br><span class="hljs-built_in">tril</span>(A) <span class="hljs-comment">%创建一个与矩阵A大小相同的下三角矩阵，其中的主对角线元素为A中相应的元素，其余为0</span><br><br><span class="hljs-comment">%% 矩阵的变形操作</span><br><span class="hljs-built_in">fliplr</span>(A) <span class="hljs-comment">%逆序排列矩阵A的每一行</span><br><span class="hljs-built_in">flipud</span>(A) <span class="hljs-comment">%逆序排列矩阵A的每一列</span><br><span class="hljs-built_in">flipdim</span>(A,dim) <span class="hljs-comment">%生成一个在第dim维矩阵A内的元素交换位置的多维矩阵,n为1的时候在行上，n为2的时候在列上?</span><br><span class="hljs-built_in">rot90</span>(A) <span class="hljs-comment">%生成一个由矩阵A逆时针旋转90°而得到的新矩阵</span><br><span class="hljs-built_in">reshape</span>(A,m,n) <span class="hljs-comment">%生成一个m*n维的矩阵，其元素以线性索引的方式从矩阵A中顺序取得，其中的元素个数需要相同</span><br><span class="hljs-built_in">cat</span>(dim,A,B) <span class="hljs-comment">%将矩阵A与矩阵B在dim个维度上拼接成新的矩阵</span><br><span class="hljs-built_in">permute</span>(A,order) <span class="hljs-comment">%根据向量order改变矩阵A中的维数顺序</span><br><span class="hljs-built_in">ipermute</span>(A,order) <span class="hljs-comment">%进行permute命令的逆变换</span><br><span class="hljs-built_in">sort</span>(A) <span class="hljs-comment">%对一维或者二维矩阵进行升序排列，并返回排序后的矩阵，当A是二维矩阵，对矩阵A的每一列分别进行排序。</span><br><br><span class="hljs-comment">%%矩阵的下标引用</span><br><span class="hljs-comment">%matlab中的矩阵是按照列索引的，分为单索引和双索引</span><br>A(n) <span class="hljs-comment">%通过单索引的方式找到一个数值</span><br>A(:,n) <span class="hljs-comment">%第n列</span><br>A(<span class="hljs-built_in">i</span>,:) <span class="hljs-comment">%第i行</span><br>A(:,m:n) <span class="hljs-comment">%第m列到第n列</span><br>A(<span class="hljs-built_in">i</span>:<span class="hljs-built_in">j</span>,:) <span class="hljs-comment">%第i行到第j行</span><br>A(<span class="hljs-built_in">i</span>:<span class="hljs-built_in">j</span>,m:n)<span class="hljs-comment">%第i行到第j行和第m列到第n列的交集</span><br>A(:) <span class="hljs-comment">%返回一个由矩阵A所有的列向量拼接而成的列向量</span><br>A(<span class="hljs-built_in">i</span>:<span class="hljs-built_in">j</span>) <span class="hljs-comment">%返回一个A(:)中的第i行到第j行转置的行向量。</span><br>A([i1 i2]) <span class="hljs-comment">%返回A(:)中的il、i2中的元素组成的行向量</span><br>A(:,[m1 m2 ...]) <span class="hljs-comment">%返回的一个是由矩阵A的第m1,m2等列向量构成的子矩阵。</span><br>A([i1 i2],:) <span class="hljs-comment">%返回的是由矩阵A中第i1、i2等行向量构成的子矩阵</span><br>A([i1 i2],[m1,m2]) <span class="hljs-comment">%返回矩阵A中第il,i2等行向量和第m1、m2等构成的列向量。</span><br><br><span class="hljs-comment">%%获取矩阵的信息</span><br><span class="hljs-built_in">isempty</span>(A) <span class="hljs-comment">%是否为空</span><br><span class="hljs-built_in">isscalar</span>(A) <span class="hljs-comment">%是否是单元素标量矩阵</span><br><span class="hljs-built_in">isvector</span>(A) <span class="hljs-comment">%是否是行向量或者是列向量</span><br>issparse(A) <span class="hljs-comment">%是否是稀疏矩阵</span><br><span class="hljs-built_in">ndims</span>(A) <span class="hljs-comment">%获取矩阵A的维数</span><br><span class="hljs-built_in">size</span>(A) <span class="hljs-comment">%获取矩阵A的尺寸</span><br><span class="hljs-built_in">length</span>(A) <span class="hljs-comment">%获取矩阵A的最长的维度长度</span><br><span class="hljs-built_in">numel</span>(A) <span class="hljs-comment">%获取元素的个数</span><br><br><br><span class="hljs-comment">%%矩阵的运算</span><br><span class="hljs-comment">%乘法运算和除法运算都需要满足格式上的需求、方阵才可以使用幂运算</span><br><span class="hljs-comment">%需要注意的是 .* 和 *是不一样的 *相对于矩阵来说是矩阵的运算，而.*相当于对应的数值相乘。同理/也适用</span><br>det(A) <span class="hljs-comment">%矩阵的转置</span><br>inv(A) <span class="hljs-comment">%矩阵的逆</span><br>rank(A) <span class="hljs-comment">%矩阵的秩</span><br>eig(A) <span class="hljs-comment">%矩阵的特征值</span><br>A=<span class="hljs-built_in">rand</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br>B=<span class="hljs-built_in">ones</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br>C=A&gt;B <span class="hljs-comment">%其中矩阵C中为1代表A中这个位置的值大于B中这个位置的值。</span><br><span class="hljs-comment">%%同理&lt; &lt;= ~=(不等关系) 以及逻辑运算 &amp; | xor not</span><br><br><span class="hljs-comment">%%取整运算</span><br><span class="hljs-built_in">floor</span>(A) <span class="hljs-comment">%正无穷取整</span><br><span class="hljs-built_in">ceil</span>(A) <span class="hljs-comment">%负无穷取整</span><br><span class="hljs-built_in">round</span>(A) <span class="hljs-comment">%A中按照最接近的整数取整即四舍五入</span><br><span class="hljs-built_in">fix</span>(A) <span class="hljs-comment">%按照离0近的方向取整</span><br><br><span class="hljs-comment">%%矩阵的分解</span><br>[L,U]=lu(X) <span class="hljs-comment">%对X矩阵进行LU 分解</span><br>[Q,R]=qr(X) <span class="hljs-comment">%对矩阵X进行QR分解</span><br><br><span class="hljs-comment">%%查找最值与查找值</span><br><span class="hljs-built_in">max</span>(A) <span class="hljs-comment">%取矩阵A的每一列最大值，组成行向量</span><br><span class="hljs-built_in">max</span>(A,B) <span class="hljs-comment">%取矩阵A和B所对应位置上的最大值</span><br><span class="hljs-built_in">max</span>(A,[],dim) <span class="hljs-comment">% dim等于1 时候为max(A) ,dim等于2的时候为矩阵A的每一行最大值组成列向量</span><br><span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(A)) <span class="hljs-comment">%取矩阵A的最大值</span><br><br>ind= <span class="hljs-built_in">find</span>(X) <span class="hljs-comment">%返回单索引下标</span><br>[m n]=<span class="hljs-built_in">find</span>(X) <span class="hljs-comment">%返回双索引下标 </span><br></code></pre></td></tr></table></figure><hr><h3 id="1-2MATLAB编程基础">1.2MATLAB编程基础</h3><p>针对这部分的编程基础中的<code>if</code> <code>else</code>  <code>for </code> <code>while</code> 其实是和C语言C++语言等一般语言是差不多的，只是结束的时候需要<code>end</code>。</p><p>而matlab中特殊的地方就是</p><blockquote><p>函数句柄、匿名函数</p></blockquote><h4 id="函数句柄">函数句柄</h4><p>函数句柄给人的感觉就好像是函数指针通过 <code>mysin=@sin</code> 此时就可以直接使用<code>mysin</code> 函数来当作<code>sin</code> 函数使用。</p><h4 id="匿名函数">匿名函数</h4><p>匿名函数就像是函数句柄的一种特殊的方式高级用法。此时可以是函数的表达式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f=@(x)(x.^<span class="hljs-number">2</span>)<br>f(<span class="hljs-number">2</span>) <span class="hljs-comment">%4</span><br></code></pre></td></tr></table></figure><h4 id="编程技巧">编程技巧</h4><p>利用 <code>tic</code> <code>toc</code> 可以用来求函数运行的时间。</p><hr><h3 id="1-3基于simulink的仿真">1.3基于simulink的仿真</h3><p>使用图形化的系统模块对研究对象进行描述， 每个模块像实验室中的每一台仪器一样，可以根据需要进行不同的组合以达到不同的研究目的。</p><hr><h2 id="第二、三章：计算机视觉与数字图像处理基础-基于系统对象编程">第二、三章：计算机视觉与数字图像处理基础+基于系统对象编程</h2><p>因为第二章是讲解了一些基础知识，感觉纯纯看完基础知识再看第三章的编程部分就没忘光了（主要也是一直看基础知识太无聊了根本看不下去！！看一小时睡三小时！！）所以想着两章一起做个记录。</p><hr><h3 id="视频的边缘检测">视频的边缘检测</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 对视频进行边缘检测</span><br>clc;<br>clear all;<br>close all;<br>hvideosrc = vision.VideoFileReader(<span class="hljs-string">&#x27;vipmen.avi&#x27;</span>, <span class="hljs-string">&#x27;ImageColorSpace&#x27;</span>, <span class="hljs-string">&#x27;Intensity&#x27;</span>);<br><br>WindowSize = [<span class="hljs-number">190</span> <span class="hljs-number">150</span>];<br>hvideoorig = vision.VideoPlayer(<span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Original&#x27;</span>);<br>hvideoorig.Position = [<span class="hljs-number">10</span> hvideoorig.Position(<span class="hljs-number">2</span>) WindowSize];<br>hvideoedge = vision.VideoPlayer(<span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Edges&#x27;</span>);<br>hvideoedge.Position = [<span class="hljs-number">210</span> hvideoorig.Position(<span class="hljs-number">2</span>) WindowSize];<br><br><span class="hljs-keyword">while</span> ~isDone(hvideosrc)<br>    frame = step(hvideosrc);<br>    <br>    <span class="hljs-comment">% 手动进行边缘检测</span><br>    edges = edge(frame, <span class="hljs-string">&#x27;Prewitt&#x27;</span>, <span class="hljs-number">15</span>/<span class="hljs-number">256</span>); <span class="hljs-comment">% 可以尝试不同的方法和阈值</span><br>    <br>    step(hvideoorig, frame);<br>    step(hvideoedge, edges);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="灰度直方图">灰度直方图</h3><p>图像的灰度是在RGB空间内， <code>R=G=B</code> 的时候 ，图像显示是灰度的，其中求将一幅彩色的图片转化为灰度图片可以采用以下这三种方式：</p><p>最大值法 ：选取<code>R、G、B</code>中的值最大的一个值，同时将最大值赋给<code>R、G、B</code> 保证三者的值相同。</p><p>平均值法：选取<code> R、G、B</code> 的均值来当作<code>R、G、B</code> 三者的值。</p><p>加权法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clc; <br>clear all; <br>close all;<br><br>I = rgb2gray(imread(<span class="hljs-string">&#x27;PeppersRGB.bmp&#x27;</span>));<br>imshow(I);<br><br><span class="hljs-comment">% 将图像转换为单精度数据类型</span><br>img = im2single(I);<br><br><span class="hljs-comment">% 计算直方图</span><br>hist_values = imhist(img);<br><br><span class="hljs-comment">% 绘制直方图</span><br><span class="hljs-built_in">figure</span><br>bar(hist_values, <span class="hljs-string">&#x27;hist&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;灰度级别&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;像素数&#x27;</span>);<br>title(<span class="hljs-string">&#x27;图像的灰度直方图&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="色彩空间">色彩空间</h3><h3 id="缩放变换">缩放变换</h3><h3 id="平移变换">平移变换</h3><h3 id="旋转变换">旋转变换</h3><h3 id="傅里叶变换">傅里叶变换</h3><h3 id="余弦变换">余弦变换</h3><h3 id="图像的腐蚀和膨胀">图像的腐蚀和膨胀</h3><h3 id="图像的开运算、闭运算">图像的开运算、闭运算</h3><h3 id="图像的中值滤波">图像的中值滤波</h3><h3 id="图像的角点检测">图像的角点检测</h3><h3 id="图像的边缘检测">图像的边缘检测</h3>]]></content>
    
    
    <categories>
      
      <category>CV</category>
      
    </categories>
    
    
    <tags>
      
      <tag>record</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Self_introduction</title>
    <link href="/blog.github.io/2023/09/20/Self-introduction/"/>
    <url>/blog.github.io/2023/09/20/Self-introduction/</url>
    
    <content type="html"><![CDATA[<h1 style="color :#4682B4; ">自我介绍</h1><h2 style="color :#00BFFF;">一：兴趣爱好</h2><h3 style="color :#32CD32;">1：听歌：流行、爵士、雷鬼、摇滚。</h3><p>最近偏爱的歌曲是《kiss  me kiss me》</p><p><img src="https://img1.imgtp.com/2023/09/22/X6USNOoj.png" alt="blog1.png"></p><p>最近偏爱的歌手是爱谬</p><p>百度百科的链接为 ：<a href="https://baike.baidu.com/item/%E7%88%B1%E7%BC%AA">爱缪_百度百科 (baidu.com)</a></p><p>除此之外大概就是喜欢睡觉、喜欢熬夜，闲着没事玩两把扫雷，其余大概就没有了。</p><h2 style="color :#00BFFF;"> 二：成就？</h2><p>大概就是高数下册满分、美赛依靠队友获得了H奖，纯靠自己的话感觉S都困难 。</p><p>除了这些感觉在专业上，貌似没什么值得拿出手的成就了。自己感觉自己的专业能力真的是差的一批，但是好像目前除了努力也没有什么方法能改变现状。可谓是上不如学长学姐，下不如学弟学妹，中不如同级。</p><p>感觉自己缺少的东西包括数学知识不太扎实、算法一塌糊涂、编程能力也差得一批。</p><p>如果要说自己对哪类方向是感兴趣的，以前大概对底层有点兴趣（因为好像薪资高一点），但是现在被计组狠狠的打击了一下，感觉图像处理也很有意思，但是貌似自己的专业技能离做研究还差远了…</p><p>希望自己能在大三这一年增强一些专业技能和数学方法吧。</p><h2 style="color :#00BFFF;"> 三：未来规划</h2><p>关于未来到底干什么这件事是想过很多的，既想找到一个安稳的生活，比如考公，也想过一些不太安稳的比如直接就业。现在谈规划感觉还是有一种操之过急的感觉。</p><p>如果有可能的话，大概会去读研究生，找一个好一点的高校，之后再去就业，赚够了就去找个地方学临床医学（梦想！），过个十几年去当医生。</p><p>如果没可能的话，大概会直接去就业，干个几年被优化，之后再去小一点的地方继续干，干了几年再被优化…。</p><p>每种生活都有每种生活的有趣性吧。</p>]]></content>
    
    
    <categories>
      
      <category>SoftWare engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HomeWork</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/blog.github.io/2023/09/20/hello-world/"/>
    <url>/blog.github.io/2023/09/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Default</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
