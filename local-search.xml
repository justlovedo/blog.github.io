<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>听力日常-11-13</title>
    <link href="/blog.github.io/2023/11/13/2023-11-13-%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-11-13/"/>
    <url>/blog.github.io/2023/11/13/2023-11-13-%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-11-13/</url>
    
    <content type="html"><![CDATA[<h1>2023-11-13</h1><h1>Unit Test</h1><p><code>cocktail</code> ：鸡尾酒</p><p><code>Gymnastics and balance skills.</code> ：体操和平衡能力</p><p><code>Citizenship</code> ：公民身份</p><p><code>daycare</code> ：日托所</p><p><code>curriculum</code> ：课程设计</p><p><code>hostility</code> ： 敌意、敌对性</p><p><code>supervision</code>：监管</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-11-12</title>
    <link href="/blog.github.io/2023/11/12/11-12/"/>
    <url>/blog.github.io/2023/11/12/11-12/</url>
    
    <content type="html"><![CDATA[<h1>2023-11-12</h1><p>Unit 5</p><h1>Listen in</h1><h2 id="生单词">生单词</h2><p><code>lead</code>：铝</p><p><code>toxic</code> ： 有毒的物质</p><p><code>resident</code> ：居民</p><p><code>taps</code> ：水龙头</p><p><code>The day Australia became a country.</code> ：澳大利亚建国之日</p><p><code>wartime</code> ： 战争时期 <code>war</code>+<code>time</code></p><p><code>Aborigina</code> ：原住民</p><p><code>controversy</code> ： 争议中</p><p><code>synergy</code>  ：协同作用</p><p><code>conservative</code> :保守</p><p><code>conscientious perfectionist</code> ： 尽善尽美</p><p><code>hut</code> ： 小屋</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog.github.io/2023/11/10/%E5%BB%BA%E5%85%9A%E4%BC%9F%E4%B8%9A/"/>
    <url>/blog.github.io/2023/11/10/%E5%BB%BA%E5%85%9A%E4%BC%9F%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<h1>建党伟业</h1><p>讲述的历史时期为 ： 1911 - 1921 。</p><p>光复会 ，同盟会。</p><p>陶成章、陈其美。孙文</p><p>1912年 1.1 日 孙文到达南京 十点宣告中华民国成立 。临时大总统</p><p>1912.1.14 上海广慈医院 陶成章被杀</p><p>毛泽东光复新军</p><p>南京 南北和谈历时3月。唐邵仪。-北洋军阀</p><p>吾廷芳</p><p>袁世凯 。隆裕太后 。载洋。溥仪。</p><p>1912.2.12 溥仪退位，辛亥革命推翻</p><p>1912.2.15 孙文退任。</p><p>1912。3.10 袁世凯临时大总统。</p><p>中华民国临时约法。</p><p>宋教仁 。</p><p>冯国璋</p><p>1913.3.20 宋教仁火车站被杀。</p><p>于右任。</p><p>3.22 宋教仁去世引发第二次南北战争。</p><p>1913.9.1 北洋军攻克南京，二次革命失败，孙文流亡日本 同年 11月袁世凯解散国民党。</p><p>日本君主立宪制，法兰西的共和制，美利坚的联合制。</p><p>黎元洪 蔡锷 蒋百里</p><p>1919 年 12.23清晨，袁世凯率幕僚在天坛举行祭天仪式，做起称帝的美梦</p><p>1914.7. 13日第二次时间大战 。11。14 德军 投降日本接管青岛。</p><p>伊藤博文 。</p><p>1915年5月九日 为实现称帝梦想，袁世凯秘密接受了丧权辱国的21条</p><p>陈独秀在上海创建新青年</p><p>袁克定 改国体 ： 中华帝国皇帝。</p><p>杨昌济 杨开慧</p><p>蔡锷与 孙文在日本相见。</p><p>1915年12.25日 蔡锷返回云南，誓师讨袁，率军入川</p><p>朱德 蔡锷的军队 。</p><p>蔡锷棉花破以少胜多 吴佩孚。</p><p>广西 陆荣廷 宣布独立 。</p><p>陈宦 曹锟 打蔡锷</p><p>段祺瑞 - 赵本山</p><p>袁世凯 袁克定想改国体，但是蔡锷 陆荣廷 不同意。</p><p>1916年 袁世凯在举国声讨中死去，皇帝梦灰飞烟灭，北洋政府分崩离析，中国依然贫弱不堪</p><p>陈独秀- 北京大学文科长</p><p>李大钊 图书馆主任</p><p>辜鸿铭 英文教授</p><p>保皇党 张勋入京</p><p>康有为 张勋 复辟 。</p><p>1917年7月12日 张勋复辟12天失败，孙中山在广州发起护法运动</p><p>封建与共和乃绝对两不相容之物。</p><p>推崇新文化，埋葬旧文化。</p><p>新文化运动</p><p>胡适</p><p>十月革命一声炮响，给中国送来了马克思列宁主义，中国出现了一批追随革命 具有初步共产主义思想的知识分子，社会主义开始成为了具有深远影响的思想潮流</p><p>​</p><p>1918年 1月30日 冯国璋下令讨伐孙文 3月26日 吴佩孚率兵占领长沙</p><p>段祺瑞 ，吴佩孚， 张勋 黎元洪 。护法运动</p><p>南方打完了北方打 。</p><p>缺钱缺枪缺军队。</p><p>中国不能失去山东，就像西方不能失去耶路撒冷。德国在山东的权益 交给 日本。威尔逊十四条</p><p>1919年3月2 日 共产国际在莫斯科成立 推动了许多国家民族解放运动和人民革命斗争的发展</p><p>出去就是为了回来 。</p><p>章宗祥 ：与日本签订合约的。  巴黎和谈 失败</p><p>1919年 五月四日 五四运动爆发了 。 列强的帮凶，倭寇的走狗 。</p><p>邓中夏 ， 万豪  32名青年学生被捕入狱 。</p><p>徐世昌 。</p><p>1919年6月28日 中国代表团拒绝在 《凡尔赛和约》上签字</p><p>98 天后释放陈独秀 。</p><p>1919年12月18日 毛泽东率驱张代表团赴京请愿</p><p>1920年 1月17日 北京德国医院 杨昌济病危</p><p>天津公署</p><p>1920.1.9 周恩来领导学生运动被抓。</p><p>陈独秀领导工人运动罢工。</p><p>在狱中周恩来坚持斗争，宣传马克思主义 173后 政府被迫释放学生</p><p>出狱不久之后，周恩来等人赴法勤工俭学 参与创建中共旅法支部 为中国革命储备了重要的政治力量。</p><p>1920年 夏至1921年春 随着马克思主义的广泛传播</p><p>团结农工，团结工人。建立布尔甚维克。</p><p>1921年6月3日李大钊领导北京教室讨薪运动，遭遇军警的袭击</p><p>1921年 7 月9日 刘少奇 张太雷 翟秋白 参加共产国际第三次代表大会</p><p>乌拉！！！</p><p>因为意见不一致，所以陈独秀、李大钊不参加中共一大。</p><p>1921年 6 月中旬至七月上旬 全国各地共产主义组织代表陆续抵达上海</p><p>北京代表张国焘 ，刘文静 。 济南代表 邓恩铭。陈独秀 包惠僧 。王会悟 。望志路106号 。 毛润之，大会书记员。</p><ul><li>确定党的名称 。 中国共产党 、中国共产党</li></ul><p>被人跟踪   。 职员进出 。 间谍 ，</p><p>陈公博 回广东 。嘉兴南湖 。</p><p>红船选举党的中央机构 。</p><p>这个天是天下的天，工农大众就应该是这天下的主人</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-11-09</title>
    <link href="/blog.github.io/2023/11/09/2023-11%20-0%209/"/>
    <url>/blog.github.io/2023/11/09/2023-11%20-0%209/</url>
    
    <content type="html"><![CDATA[<h1>2023-11 -0 9</h1><p>Unit 5</p><h2 id="Outside-View">Outside View</h2><h3 id="passage1">passage1</h3><p><code>territory</code>  : 领土</p><p><code>seal</code> : 海豹</p><p><code>shove</code> : 推搡</p><p><code>producer</code> : 制片人</p><p><code>mating season</code> : 交配的季节</p><p><code>parking space </code>： 停车的地方</p><h3 id="passage2">passage2</h3><p><code>counsel</code> : 咨询</p><p><code>beep the horn</code> : 鸣笛</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-11-08</title>
    <link href="/blog.github.io/2023/11/08/2023-11-08/"/>
    <url>/blog.github.io/2023/11/08/2023-11-08/</url>
    
    <content type="html"><![CDATA[<h1>2023-11-08</h1><h2 id="Unit-Test-5">Unit Test 5</h2><h3 id="Inside-View">Inside View</h3><h4 id="Conversation1">Conversation1</h4><p><code>Cantonese </code> : 广东人</p><p><code>ethinc</code> : 种族</p><p><code>Chinatown</code> : 唐人街</p><h4 id="Conversation2">Conversation2</h4><p><code>Laundries</code> : 洗衣店</p><p><code>entertainment</code> ： 娱乐场所</p><p><code>Sailor</code> : 水手</p><p><code>let's wind it up</code> : stop it .</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/blog.github.io/2023/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/blog.github.io/2023/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1><a href>计算机网络</a></h1><p>自下而上的讲解计算机网络与中科大的课程自上而下是不一样的。</p><h2 id="第一章概论"><strong>第一章概论</strong></h2><p>电信网络 + 有线电视网络 = <strong>计算机网络</strong> 三网合一。</p><p>Internet = 互联网 ！= 互连网 互连网是局部范围内连起来的计算机网络。</p><p><strong>互连网</strong>是由路由器，主机等互连成的网络。</p><p><strong>互联网</strong>是最大的<strong>互连网</strong>，特指覆盖全球的、具有<strong>连通性和资源共享</strong>的<strong>计算机网络</strong>。</p><p>计算机网络之间的通信指的是 <strong>端到端</strong> 的通信，即是主机之间 <strong>进程</strong> 的通信。</p><hr><h3 id="1-1互连网的基本特点"><strong>1.1互连网的基本特点</strong></h3><p>1：连通性  （不连通怎么连接成互联网络？？）</p><p>2：资源共享性  （信息共享、软件共享、硬件共享）</p><hr><h3 id="1-2计算机网络的组成"><strong>1.2计算机网络的组成</strong></h3><p>由若干<strong>节点</strong>和连接这些<strong>节点</strong>的链路组成。 <strong>节点</strong> 可以是 计算机、集线器、交换机或者是路由器等。</p><hr><h3 id="1-3计算机网络的发展历史">1.3计算机网络的发展历史</h3><h4 id="第一阶段">第一阶段</h4><h5 id="ARPANET"><code>ARPANET</code></h5><p>最初只是一个单个的分组交换网，不是一个互连网。供给军事使用。</p><h5 id="TCP-IP"><code>TCP/IP</code></h5><p>成为 <code>ARPANET</code> 上的标准协议，使得所有使用<code>TCP/IP</code>协议的计算机都能利用 <strong>互连网</strong> 相互通信。 1983年互联网诞生的标志。</p><h5 id="ARPNET关闭"><code>ARPNET关闭</code></h5><hr><h4 id="第二阶段">第二阶段</h4><p>形成三级结构： <strong>主干网、地区网、校园网（或企业网）</strong></p><hr><h4 id="第三阶段">第三阶段</h4><h5 id="ISP"><code>ISP</code></h5><p>出现了<strong>互联网服务提供者</strong>，即三大运营商 （联通、电信、移动）。需要接入到互联网服务，收取一定的费用。</p><h5 id="多层次的ISP结构"><code>多层次的ISP结构</code></h5><p>主干ISP、地区ISP、本地ISP、校园网…、公司网络、…、主机</p><hr><h5 id="通信举例">通信举例</h5><pre><code class=" mermaid">graph LR主机A --&gt; 本地ISP_A --&gt; 地区ISP_A --&gt; 主干ISP --&gt; 地区ISP_B --&gt;本地ISP_B --&gt;主机B</code></pre><p><code>IXP</code> ： 互连网交换点，允许两个网络直接连接并快速交换分组。 提供转接服务</p><p>内容提供者 ： 提供软件资源而不是转接服务，例如 ： 视频、照片、文章。</p><hr><h4 id="万维网">万维网</h4><p>即 <code>WWW</code>  即 <code>World Wide Web</code></p><p style="color :red; font-size :40px; font-style : bond">万维网之父 ： 蒂姆·伯纳斯·李</p><blockquote><p><a href="http://info.cern.ch">http://info.cern.ch</a>    <strong>home of first website</strong></p></blockquote><p><strong>没有他就没有互联网发展的今天。</strong></p><hr><h4 id="互联网标准化工作">互联网标准化工作</h4><p>以 <code>RFC</code> 的方式来进行标准的发表。</p><blockquote><p><code>RFC </code> : <code>Request For Comments</code>  (请求评论)</p></blockquote><p>并非所有的 <code>RFC </code> 文档都是互联网标准。 只有很少部分的 <code>RFC</code> 文档才会变成标准。</p><hr><h4 id="计算机网络在我国的发展">计算机网络在我国的发展</h4><p><strong>出口带宽</strong> 的不一样决定网速的快慢。</p><blockquote><p>?</p></blockquote><p><code>CNNIC</code> 可以查阅我国互联网的发展情况。</p><p>中国电信网的出口带宽最多，所以以后办卡用电信卡（bushi。</p><p>吸引用户 + 留住用户</p><h3 id="1-4互联网的组成">1.4互联网的组成</h3><h4 id="边缘部分">边缘部分</h4><p>由所有连接在互联网上的主机组成，由用户直接使用。用来进行 <strong>通信</strong> 和 <strong>资源共享</strong>  <strong>——</strong> <strong>资源共享</strong></p><p>连接在互联网端的所有的主机  ：<strong>端系统</strong>  <code>end system</code>   <strong>不负责数据的转发</strong></p><h5 id="端系统的通信">端系统的通信</h5><blockquote><p>主机 = <code>host</code>  包括： 桌面计算机、移动计算机、服务器、其他智能终端服务</p></blockquote><p><strong>主机之间的通信</strong>指的是 主机之间的<strong>进程</strong>之间的通信。</p><h6 id="客户服务器方式-CS">客户服务器方式  CS</h6><blockquote><p>进程之间服务和被服务的关系，通信是双向的。</p></blockquote><p>客户主动发起。服务器不断地运行着，被动等待客户端发起。</p><h6 id="点到点的方式-P2P">点到点的方式 P2P</h6><p>主机之间通信的时候不区分服务的请求方和服务的提供方。<strong>平等、对等连接通信</strong></p><p>本质来说仍然是客户服务器模式，但是此时客户和服务器的双方不是固定的双方。</p><hr><h4 id="核心部分">核心部分</h4><p>由大量 <strong>网络</strong> 和连接这些网络的 <strong>路由器</strong> 组成 ， 为<strong>边缘部分</strong> 提供服务  <strong>——</strong> <strong>连通性</strong></p><p>核心部件是 <strong>路由器</strong>  ，<strong>路由器</strong> 采取的方法是<strong>分组交换</strong>和<strong>转发</strong>。</p><h5 id="为什么采用分组交换？">为什么采用分组交换？</h5><hr><h6 id="电报交换">电报交换</h6><p>如果<strong>n</strong>个主机采用主机和主机<strong>两两直接相连</strong>的方式来进行相互通信，那么需要 **<code>(n*n-n)/2</code>**次连接。</p><p>于是可以使<strong>交换机</strong>来实现链接的话只需要  <strong><code>n</code></strong> 条 。</p><p>交换机的阶段：</p><ul><li>建立连接 ： 占用通信资源</li><li>通话 ： 主叫和被叫双方互相通电话（<strong>一直占用端到端的全部通信资源</strong>）</li><li>释放连接 ： 释放刚才使用的通信线路（释放通信资源）。</li></ul><p>在电路交换的时候，如果有主机在通信的话，就会发生占线。</p><p>由于数据具有 <strong>突发性</strong> 电报交换的时间利用率很低。</p><p>通过<strong>电报交换</strong>打电话的方式是物理连接线路。</p><hr><h6 id="分组交换">分组交换</h6><p><strong>优缺点</strong></p><p>优点：动态分配、逐段占用、迅速（不需要建立连接）、是可靠性的网络协议。</p><p>缺点：排队延迟、不保证带宽，因为是动态分配带宽、增加开销，因为存在首部。</p><p>采用 <strong>存储转发</strong> 的方式。</p><blockquote><p>存储转发的对象是 <strong>分组</strong></p></blockquote><p>根据不同的 <strong>协议</strong> 将原始数据报分成不同的<strong>分组数据报</strong>，同时在小数据报之前放一个 <strong>首部</strong></p><blockquote><p>首部的内容由 <strong>协议</strong> [确定</p></blockquote><p>交换设备的报文交换流程。</p><pre><code class=" mermaid">graph TDA(暂存收到的分组) --&gt; B(检查分组首部)--&gt; C(查找转发表) --&gt;D(按照首部中的目的地址找到合适的接口转发出去)</code></pre><hr><h6 id="报文交换">报文交换</h6><p>分组交换是基于报文交换的。</p><p>报文交换是将报文变成一组一组的数据，但是每组数据的转发是跟<strong>电路交换</strong>一样的。</p><h6 id="比较">比较</h6><ul><li>电路交换适合传输大量数据的时候。</li><li>分组交换因为是小分组，所以具有延迟性小，更有灵活性。</li><li>报文交换和分组交换都可以提高信道的利用率。</li></ul><hr><h3 id="1-5计算机网络的类别">1.5计算机网络的类别</h3><h4 id="计算机网络的定义">计算机网络的定义</h4><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过<strong>通信线路连接</strong>起来，在网络操作系统，设备管理软件及网络通信协议的管理和协调下，实现<strong>资源共享和信息传递</strong>的计算机系统</p><blockquote><p>为保持互联网的连通性和资源共享性。</p></blockquote><hr><h4 id="分类">分类</h4><h5 id="作用范围分类">作用范围分类</h5><p><strong>广域网</strong>  ： <strong>几十到几千公里</strong> 。有时也成为远程网 。是互联网的 <strong>核心部分</strong>。 <strong>PPP协议</strong></p><p><strong>城域网</strong> ： 作用范围i<strong>一般是一个城市</strong> 。作用范围为5-50公里 。 <strong>广播协议</strong></p><p><strong>局域网</strong> ： 局限在较小的范围，一公里左右，采用 <strong>高速通信线路</strong></p><p><strong>个人区域网</strong> ： 范围很小 <strong>10米左右</strong> 。无线个人区域网 <strong>WPAN</strong>  <strong>Wireless PAN</strong>。</p><hr><h5 id="网络使用者分类">网络使用者分类</h5><p><strong>公用网</strong> ：交费即可使用</p><p><strong>专用网</strong> ： 为特殊业务工作的需要而建造的网络。</p><p><strong>接入网</strong> ： 本地接入网、居民接入网。既不是核心也不是边缘部分。是从某个用户端系统到本地ISP的<strong>第一个路由器</strong>之间的一种网络。接入网起到与互联网连接的桥梁作用。</p><hr><h3 id="1-6计算机网络的性能">1.6计算机网络的性能</h3><h4 id="速率">速率</h4><p>在香浓定理中，<strong>比特</strong>成为信息的基本单位。</p><p><strong>速率</strong> 指的是<strong>数据传输的速率</strong>，即数据率或比特率，指<strong>理想状态</strong>下，<strong>一定时间</strong>内网络信道能通过的<strong>最大数据量</strong>。与一般理解的 <strong>车速</strong>是不同的。</p><p><strong>单位</strong> <code>bits/s</code> 、 <code>kbits/s</code> 、<code>Mbits/s</code> 、<code>Gbits/s</code> 单位的跨越是1000。</p><hr><h4 id="带宽"><strong>带宽</strong></h4><h5 id="频域">频域</h5><p>指的是频带带宽，即信道允许通过的信号频带范围称为该信道的 <strong>带宽</strong></p><p><strong>单位</strong> <code>Hz</code> 。</p><hr><h5 id="时域">时域</h5><p>指的是<strong>网络中某通道传送数据的能力</strong>，表示单位时间内网络中某信道所能通过的 <strong>“最高数据率”</strong>。不是指 <strong>理想状态</strong> 下的。</p><p><strong>单位</strong> <code>bits/s</code></p><hr><h4 id="吞吐量">吞吐量</h4><p>单位时间内通过某个网络的 <strong>实际数据量</strong>。吞吐量降低会造成拥塞，排队等待。</p><hr><h4 id="时延">时延</h4><p>指 <strong>数据</strong> 从网络的 <strong>一端传到另一端</strong> 所需要的时间。</p><h5 id="1-发送时延"><strong>1 . 发送时延</strong></h5><p>数据发送端口产生的发送时延即主机内部与传播时延无关。</p><p>网络的带宽提高，提高的仅仅是数据的 <strong>发送速率</strong> 。同样的提高数据的 <strong>发送速率</strong> 也仅仅的减少了数据了 <strong>发送时延</strong> 。</p><p><strong>发送时延=数据帧长度 (bit)/发送速率(bits/s)</strong></p><h5 id="2-传播时延"><strong>2 . 传播时延</strong></h5><p>数据在信道传播的时候产生的时延</p><p><strong>传播时延 = 信道长度（米）/信号在信道上的传播速率（米/秒）</strong></p><p>自由空间的光速 ： <code>3*1e+5 km/s</code></p><p>铜线电缆 : <code>2.3*1e+5km/s</code></p><p>光纤 : <code>2*1e+5km/s8</code></p><p><strong>传播时延与带宽无关 。</strong></p><h5 id="3-处理时延"><strong>3 . 处理时延</strong></h5><p>路由器处理数据产生的时延 。发生在<strong>主机或路由器</strong>中。为处理分组所花费的时间</p><h5 id="4-排队时延"><strong>4  .排队时延</strong></h5><p>因为带宽所以数据需要进行排队等待的时延。发生在 <strong>路由器</strong>中</p><p>分组在路由器的输入输出队列中<strong>排队等待处理和转发</strong>所经历的时延。</p><p>当网路的通信量很大的时候会出现队列溢出导致分组丢失，造成排队时延无穷大。</p><hr><h5 id="总时延">总时延</h5><p><strong>单边总时延。</strong></p><p><strong>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。</strong></p><pre><code class=" mermaid">graph TD</code></pre><p>不知道哪个时延是占据主导地位的，应该具体问题具体分析。</p><hr><h5 id="5-：时延带宽积">5 ：时延带宽积</h5><p>**时延带宽积  = 传播时延 * 带宽 ** ，即按照 <strong>比特</strong> 计数的 <strong>链路长度</strong>。</p><p>全部沾满的管道才会充分利用。是当前信道的整体的容纳程度。</p><p>管道中的比特数表示 <strong>从发送端发出但尚未到达接收端的比特数</strong> 。</p><p>速率是标称值，带宽是实际值。带宽可以是瓜分速率，后者是速率的结合。</p><hr><h5 id="6-：-往返时间RTT">6 ： 往返时间RTT**</h5><p><strong>RTT = 发送方发送完数据 到 发送方收到来自接收方的确认 总共经历的时间。</strong></p><p><strong>有效数据率= 数据长度 / （发送时间 + RTT）。</strong></p><hr><h5 id="7-：-利用率"><strong>7 ： 利用率</strong></h5><p>信道利用率指某信道有百分之几的时间在利用该信道，完全空闲的信道利用率为0</p><p>网络利用率指全网络信道利用率的加权总和。</p><p>**D = D0 / 1 - U **</p><blockquote><p>D : 当前时延</p><p>D0 : 网络空闲的时延</p><p>U ： 网络的当前利用率</p></blockquote><hr><h3 id="1-7-计算机网络的体系结构">1.7 计算机网络的体系结构</h3><p>分层的目的是：把复杂的通信问题，划分成若干较小的、比较易于研究和处理的局部问题。</p><blockquote><p>将复杂问题划分成较小的问题，使得每一个协议相对较小。</p></blockquote><p><strong>网络的体系结构</strong> ： 是计算机网络的各层及其协议的集合，就是这个计算机网络及其构件所应完成的<strong>功能的精确定义</strong>而不是实现。</p><h5 id="协议">协议</h5><h5 id="三个组成要素">三个组成要素</h5><p><strong>语法</strong>  ：规定传输数据的<strong>格式</strong>，解决交换信息的格式问题。</p><p><strong>语义</strong> ： 规定所要完成的<strong>功能</strong>，解决做什么的问题。</p><p><strong>同步</strong> ：规定各种操作的<strong>顺序</strong>，又称为<strong>时序</strong>，解决什么时间什么条件下做什么特定操作的问题。</p><h5 id="OSI七层体系结构"><strong><code>OSI</code>七层体系结构</strong></h5><pre><code class=" mermaid">graph TD应用层 --- 表示层 --- 会话层---运输层 ---网络层---数据链路层 ---物理层</code></pre><h5 id="TCP-IP四层结构"><strong><code>TCP/IP</code>四层结构</strong></h5><pre><code class=" mermaid">graph TD应用层---运输层---互联网层---网络接口层</code></pre><p>抽象分层、统一标准、模块独立。</p><h5 id="五层体系结构"><strong>五层体系结构</strong></h5><pre><code class=" mermaid">graph TD应用层--- 运输层---网络层---数据链路层---物理层</code></pre><h6 id="各层的作用">各层的作用</h6><blockquote><p>个人认为这部分先了解一下就可以了，等都学完之后再回来看一眼会更好的。</p></blockquote><p><strong>应用层</strong></p><table><thead><tr><th><strong>任务</strong> ：</th><th>通过应用进程间的交互来完成特定的网络应用。</th></tr></thead><tbody><tr><td><strong>协议</strong> ：</td><td>定义的是应用进程间通信和交互的规则。</td></tr><tr><td><strong>传输单元</strong> ：</td><td>报文</td></tr><tr><td><strong>作用</strong> ：</td><td>为用户提供服务</td></tr></tbody></table><p>*<strong>运输层</strong></p><table><thead><tr><th>任务 ：</th><th>负责向两台主机中的进程通信提供通用的数据传输服务。</th></tr></thead><tbody><tr><td><strong>功能：</strong></td><td>具有复用和分用两种功能</td></tr><tr><td><strong>TCP</strong> ：</td><td>提供 <strong>面向连接的</strong> 的 <strong>可靠数据传输</strong> 服务</td></tr><tr><td><strong>UDP</strong></td><td>提供 <strong>无连接</strong> 的<strong>尽最大努力数据传输</strong>服务</td></tr></tbody></table><p>*<strong>网络层</strong></p><table><thead><tr><th>任务</th><th>为分组交换网上的不同主机提供通信服务</th></tr></thead><tbody><tr><td><strong>路由选择</strong></td><td>通过一定的算法，再互联网中的 <strong>每一个路由器</strong> 上，生成一个用来 <strong>转发分组</strong> 的转发表。</td></tr><tr><td><strong>转发</strong></td><td><strong>每一个路由器</strong>在接收到一个分组的时候，要依据转发表中指明的路径把分组转发到下一个路由器。</td></tr><tr><td><strong>协议</strong></td><td><strong>网际协议IP</strong> 和 <strong>路由协议</strong></td></tr><tr><td><strong>传输单位</strong></td><td><strong>IP数据报</strong></td></tr></tbody></table><p><strong>数据链路层</strong> ：同一个网络中的两个相邻节点的可靠通信。差错检验、不仅增加报头还会增加报尾。</p><table><thead><tr><th>任务</th><th>实现两个相邻节点之间的可靠通信</th></tr></thead><tbody><tr><td><strong>传输单位</strong></td><td>帧</td></tr><tr><td><strong>功能</strong></td><td>封装成帧、透明传输、差错检验</td></tr></tbody></table><p><strong>物理层</strong> ：任务是实现比特的传输</p><table><thead><tr><th>任务</th><th>实现比特的传输</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>确定连接电缆的插头应该有多少根引脚、以及引脚应该如何连接</td></tr><tr><td><strong>注意</strong></td><td>传输介质应该在物理层之下。</td></tr></tbody></table><p><strong>实体</strong> ： 表示任何可发送或接收信息的硬件或软件进程。</p><p><strong>协议</strong> ：同层实体可以通信</p><p><strong>服务访问点SAP</strong> ： 交换服务原语，通过接口交换上下层信息来实现服务。</p><p><strong>服务</strong> ： 下层为上层服务，每个下层对于上层来说是透明的。</p><p><strong>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层的协议，还需要使用下层所提供的服务</strong>。</p><p><strong>每个实体都认为在与对等层之间靠这一层的协议来直接通信，实际上两层的通信都要依靠下一层的服务来实现通信。</strong></p><blockquote><p>我认为这句话简直是精髓！！！，以前一直不懂为什么要分层，为什么能通过协议对等层可以直接通信还要依靠下层的服务，直到听到这句话才明白，对等层通信指的是什么…</p></blockquote><h2 id="第二章-物理层">第二章 物理层</h2><h3 id="2-1基本概念">2.1基本概念</h3><p><strong>网络体系结构的最底层</strong>  不是具体的<strong>传输媒体</strong>，也不是连接计算机的<strong>具体物理设备</strong>。</p><h4 id="功能-：-实现比特流的传输。">**功能 ** ： 实现比特流的传输。</h4><p><strong>数据链路层将比特流交给物理层</strong>。</p><p><strong>物理层将比特流按照传输媒体的需要进行编码</strong></p><p><strong>然后将信号通过传输媒体传输到下一个节点的物理层</strong></p><h4 id="作用：-尽可能的屏蔽掉不同的传输媒体和通信手段的差异。">作用： 尽可能的屏蔽掉不同的传输媒体和通信手段的差异。</h4><blockquote><p>为数据链路层提供一个统一的数据传输服务。</p></blockquote><p>物理层的协议被称为<strong>规程</strong></p><h4 id="主要任务：确定与传输媒体的接口有关的一些特性。">主要任务：确定与传输媒体的接口有关的一些特性。</h4><p>规定<strong>数据终端接口DTE</strong>和<strong>数据电路终结设备DCE</strong>的特性：</p><p><strong>机械特性</strong> ：指明接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。即外观特性</p><p><strong>电气特性</strong> ： 指明在接口电缆的各条线的电气特性以及有关电路特性。例如电压范围、阻抗、传输速率等。</p><p><strong>功能特性</strong>  ：指明某条线上出现的某一电平的电压的意义，定义接线器的每一引脚的作用。</p><p><strong>过程特性</strong> ： 指明对于不同功能的各种可能事件的出现顺序。</p><h3 id="2-2数据通信的基本知识">2.2数据通信的基本知识</h3><h4 id="通信模型">通信模型</h4><p>三大部分 ： <strong>源系统</strong> 、<strong>传输系统</strong>、<strong>目的系统</strong>。</p><p>通信 ： 源点和终点之间传递消息或者信息、但消息和信息有着不同的概念。</p><p>消息是指能向人们表达客观物质和主观思维活动的文字、符号、数据、语音和图像</p><p>信息是指包含在消息中对通信锗有意义的那部分内容，消息是信息的载体。</p><blockquote><p>有意义的消息才是信息。</p></blockquote><p>数据指的是运送消息的实体。数据分为模拟数据和数字数据。</p><p>信号是指消息的载体，是数据的电气的或电磁的表现。</p><p>消息通过电信号来传递，电信号有模拟信号和数字信号。</p><blockquote><p>模拟信号是连续的信号 ，数字信号 是含有突变的</p></blockquote><p>信道 ： 信号传输的通道（传输媒介）， 按照数据信号在信道上的传送方向与时间的关系。</p><h4 id="传输方式">传输方式</h4><p>单向通信、双向交替通信（半双工通信）、全双工通信。</p><p>基带信号 ： 没有经过调制的原始信号。</p><p>调制的作用是让信号可以在信道中传输。</p><p>数据-&gt;数字信号 ：<strong>编码</strong>（基带调制）。</p><p>数据-&gt;模拟信号：<strong>调制</strong>（带通调制）。</p><hr><h4 id="常用编码方式">常用编码方式</h4><p><strong>不归零制</strong>  ：正电平代表1 ，负电平代表0。</p><p>缺点是不能分辨所有的0、1数据。没有同步能力</p><p><strong>归零制</strong> ： 正脉冲代表1，负脉冲代表0 。</p><p><strong>曼切斯特编码</strong> ： 位周期中心的向上跳变代表0 ，位周期中心的向下跳变代表1 。但也可以反过来。</p><p><strong>差分曼切斯特编码</strong>  ： 在每一位的中心处始终都有跳变。 位开始边界有跳变代表0，而位开始边界没有跳变代表1</p><p>不知道第一个比特是为0还是为1.</p><p>当频率相同的时候才能更好的进行同步。</p><p>曼切斯特编码和差分曼切斯特编码产生的信号频率是比不归零制高的。但是具有自同步的能力。</p><hr><h4 id="基本的带通调制方法">基本的带通调制方法</h4><p><strong>调幅</strong> ：频率一样但是幅度不一样。</p><p><strong>调频</strong>： 幅度一样但是频率不同</p><p><strong>调相</strong> ：幅度频率不变的情况下，改变其相位。</p><p><strong>正交振幅调制</strong> ：相位和振幅来决定一种信号的状态。即2个相位2个振幅的时候，就会有<code>2*2</code>四种信号状态，即有四种码元。</p><hr><p><strong>码元</strong> ： 代表不同离散数值的基本波形。</p><p>使用二进制编码的时候，只有两种不同的码元 ： 0状态，1状态。</p><p>一个码元可以携带多个比特的信息量，当码元有M个离散状态的时候，此时的码元可以称为M进制编码。</p><blockquote><p>即二进制码元可以携带的比特数为1个。码元是几进制就说明通信线路有多少种信号的离散状态。</p></blockquote><h4 id="信道的极限容量">信道的极限容量</h4><p>实际的信道中存在失真的情况。</p><p>干扰指的是大气干扰、城区人为干扰和非恶意邻道干扰。</p><p>恶意干扰 ： 指带有恶意的干扰。</p><h5 id="失真的原因-："><strong>失真的原因</strong> ：</h5><p><strong>信号传输的距离远</strong>。</p><p><strong>传输媒体的质量差</strong>。</p><p>噪声干扰 ： 环境干扰和人为恶意干扰</p><p><strong>码元的传输速率高</strong>。</p><p>当码元传输的速率很高，但是信道的带宽很低，就会造成数据的溢出。</p><p>信噪比。码元的传输速率。</p><h5 id="奈式准则"><strong>奈式准则</strong></h5><p><strong>理想的低通信道</strong>的时候，<strong>码元的传输速率为  ** $2W$。</strong> 单位为 <code>码元/秒</code>**</p><p>码间串扰 ： 接收端收到的信号波形失去了码元之间的清晰界限。</p><p><strong>码元 ！= 信息 。信息指的是比特。 码元指的是信号</strong></p><p><code>V进制码元</code>的情况下，理想低通信道下的极限传输速率=  $C=2W\log_{2}{(V)}bit/s$。</p><h6 id="意义">意义</h6><p>当码元携带了更多比特的信息量，那么就会使得信息的传输速率更高。</p><h5 id="香农定理">香农定理</h5><p>在实际上信道的情况下 <strong>信息</strong>的极限传输速率为：$C=2W\log_{2}{(1+S/N)}bit/s $</p><p>$信噪比(dB)= 10\log_{10}{S/N} $</p><blockquote><p>S : 信号的平均功率 ，N： 噪声的平均功率。</p></blockquote><h6 id="意义-v2"><strong>意义</strong></h6><p>只要信息速率低于信道的极限信息的传输速率，就可以找到一种无差错的信息的传输的方法。</p><img src="/blog.github.io/blog.github/Users\34707\AppData\Roaming\Typora\typora-user-images\image-20231102185102908.png" alt="image-20231102185102908" style="zoom:80%;"><blockquote><p>需要注意的是香农公式事实上是跟信号如何编码是无关的。因为香农定理的公式只与带宽和信噪比有关的。</p><p>但是奈式准则确实跟码元的信号编码有关的。</p></blockquote><h3 id="2-3物理层下面的传输媒体">2.3物理层下面的传输媒体</h3><h5 id="双绞线">双绞线</h5><p>通过两根线绞在一起来屏蔽电磁干扰。</p><h5 id="同轴电缆">同轴电缆</h5><h5 id="光纤">光纤</h5><p>传播的速度很快，分为</p><h3 id="2-4信道复用技术">2.4信道复用技术</h3><p>通过复用技术提高信道的利用率。</p><p><strong>频分复用</strong></p><p><strong>时分复用</strong></p><p><strong>统计时分复用</strong>**</p><p><strong>波分复用</strong></p><p><strong>码分复用CDMA</strong>**</p><h2 id="第三章-数据链路层">第三章 数据链路层</h2><p>物理层解决的是<strong>相邻诘点</strong>的透明传输比特问题。</p><blockquote><p>两个相邻结点之间只有透明传输介质。</p></blockquote><h3 id="3-1数据链路层概述">3.1数据链路层概述</h3><h3 id="3-2点对点PPP协议">3.2点对点PPP协议</h3><h3 id="3-3使用广播信道的数据链路层">3.3使用广播信道的数据链路层</h3><h3 id="3-4扩展的以太网">3.4扩展的以太网</h3><h3 id="3-5高速以太网">3.5高速以太网</h3><h2 id="第四章-网络层">第四章 网络层</h2><p><strong>网络层解决异构网络的连接和资源共享。</strong></p><p>什么是异构网络？不在同一个局域网内的。</p><p>IP数据报从源主机到目的主机的传递，网络层的实体是每个主机和路由器。</p><p>源主机需要进行的是IP数据报的封装，目标主机需要进行解封装。</p><hr><h3 id="4-1-导论">4.1 导论</h3><p>基本原理、IP协议的介绍。原理部分的服务模型和转发、路由、传统部分、SDN方面。</p><h4 id="数据平面">数据平面</h4><p><strong>转发</strong>：是<strong>局部</strong>的功能、是决定IP数据报在每一个数据交换节点的<strong>输入端口</strong>和<strong>输出端口</strong>、 依靠<strong>路由表</strong>决定端口、是数据层面的功能。</p><p><strong>转发功能</strong></p><p><strong>1：</strong> <strong>传统方式</strong> ：依靠<strong>IP目标地址+路由表</strong>。</p><p><strong>2：</strong> <strong>SDN方式</strong>：与流表匹配，需要所有的字段，源MAC、目标MAC、源IP、目标IP、很多字段。匹配成功之后可以选择 转发、block、泛红、修改字段。流表是通过专属的网络操作系统计算。 <strong>南向接口 ？</strong></p><hr><h4 id="控制平面">控制平面</h4><p><strong>路由</strong>：是<strong>全局</strong>的功能、是规划源主机到目标主机的详细<strong>路径</strong>、依靠路由选择算法<strong>计算路由表</strong>、是控制层面的功能。</p><p><strong>1：</strong> <strong>传统方式</strong>： <strong>分布式实现</strong>、转发和路由在一个路由器内独立实现、<strong>紧耦合</strong>。在路由器中实现</p><p><strong>2： SDN方式</strong>： <strong>集中式实现</strong>、在<strong>远程的服务器</strong>中实现流表，之后根据流表对分组进行处理，而不是在本地控制。</p><hr>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络第一期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog.github.io/2023/11/01/2023-11-1/"/>
    <url>/blog.github.io/2023/11/01/2023-11-1/</url>
    
    <content type="html"><![CDATA[<h1>2023-11-1</h1><p>今天因为第五单元的U校园还没有开始所以就去听六级听力吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>The Best offer</title>
    <link href="/blog.github.io/2023/10/31/The%20Best%20offer/"/>
    <url>/blog.github.io/2023/10/31/The%20Best%20offer/</url>
    
    <content type="html"><![CDATA[<h1>The Best offer</h1><p>When I finished watching “The Best Offer,” I was stunned. It wasn’t until I saw all the paintings stolen that I realized Claire was a fraud, and Robert was her accomplice. The lines that stuck in my head were: “Everything can be disguised, joy, pain, hatred, illness, recovery, and even love,” and “Forgery artists can’t help but leave their own traces.”</p><p>My reflection is that perhaps Claire did love Virgil. If she hadn’t loved him, she probably wouldn’t have said, “If anything happens to us, please remember that I truly love you.” However, when faced with the choice between love and financial gain, Claire ultimately chose money.</p><p>To be honest I can’t understand the meaning that the movie wants to deliver. This might be because I haven’t experienced love.</p><p>But I believe the movie aims to convey more than just love to us.</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-31</title>
    <link href="/blog.github.io/2023/10/31/2023-10-31/"/>
    <url>/blog.github.io/2023/10/31/2023-10-31/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-31</h1><h2 id="Unit-Test">Unit Test</h2><p><code>uniqueness</code>  ： 独特元素</p><p><code>Israeli </code>  ： 以色列</p><p><code>credit history</code>  ： 信用历史</p><p><code>reliance</code> ： 依赖</p><p><code>carry out</code> ：计划实施</p><p><code>roll out</code> ： 推出</p><p><code> cooperating</code> : 合作</p><p><code>federally insured banks</code> ： 联邦保险银行</p><p><code>lender's license </code> ： 贷款人许可证</p><p>早上听了Unit Test 的长对话和短篇新闻。短篇新闻还是听不太懂，长对话能听懂一点了。晚上再搞一个六级听力。</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-30</title>
    <link href="/blog.github.io/2023/10/30/2023-10-30/"/>
    <url>/blog.github.io/2023/10/30/2023-10-30/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-30</h1><h2 id="Listen-In">Listen In</h2><h3 id="passage2">passage2</h3><p>生单词</p><p><code>supermarket</code>  和 <code>department store</code>  居然不一样…，奇怪。</p><h2 id="Unit-Test">Unit Test</h2><p><code>preferences</code> : 偏好、喜好</p><p><code>disrepair</code> ： 年久失修</p><p><code> Neutral</code>  ：中立的</p><p>不错不错，五个短对话，对了四个。</p><p><code>disastrous.</code> ： 灾难性的</p><p><code>disgusting</code> ： 厌恶的</p><p><code>indefinitely</code> ： 无限期的</p><hr><p>难不成今天运气好了，长对话也都对了…，感觉除了细节听不懂，选项倒是能感觉到的。</p><p>因为有早八，所以只能晚上听了。差不多听了四十分钟了。</p><p><img src="https://ooo.0x0.ooo/2023/10/30/ONb8xq.jpg" alt="ONb8xq.jpg"><br><img src="https://ooo.0x0.ooo/2023/10/30/ONb28v.jpg" alt="ONb28v.jpg"></p><p>先到这了</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog.github.io/2023/10/29/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/blog.github.io/2023/10/29/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1>算法记录</h1><h2 id="第二周">第二周</h2><p>1：带空格读取string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">getline</span>(cin,str);<span class="hljs-comment">//此时str可以带空格</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-29</title>
    <link href="/blog.github.io/2023/10/29/2023-10-29/"/>
    <url>/blog.github.io/2023/10/29/2023-10-29/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-29</h1><h2 id="Listen-in">Listen in</h2><h3 id="new-reports">new reports</h3><p><code>moving day</code> ： 搬家日</p><p><code>vans</code> : 面包车</p><p><code>anniversary</code>   ： 周年纪念日</p><p><code>residential leases</code>  ：住房租约</p><p><code> renew their leases</code> ：续约</p><p><code>tenant</code>  ：房客</p><h3 id="passage1">passage1</h3><h4 id="生单词">生单词</h4><p><code> approximate</code> ： 大约</p><p><code>sleep</code> ： 睡觉</p><p><code>rough </code> ：粗鲁的</p><p><code>sleep rough </code> ： 露宿街头</p><p><code>spring</code> ：春天、听不到</p><p><code>hospital</code> ： 医院</p><p><code>Charties </code> :  慈善机构，不会拼</p><p><a href="https://img.tg/image/ONq26X"><img src="https://ooo.0x0.ooo/2023/10/29/ONq26X.jpg" alt="ONq26X.jpg"></a></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-28</title>
    <link href="/blog.github.io/2023/10/28/2023-10-28/"/>
    <url>/blog.github.io/2023/10/28/2023-10-28/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-28</h1><h2 id="Outside-view">Outside view</h2><h3 id="conversation1">conversation1</h3><p><code>semi-detached houses</code>  ：半独立式房子</p><p><code>terraced</code> ： 排屋</p><p><code>reed</code> ： 芦苇</p><p><code>DIY</code> do it yourself</p><p><code>britian</code> : 英国</p><p><code>difference </code> ： 不同点</p><p><code>cities</code> ：city的复数形式</p><p><img src="https://ooo.0x0.ooo/2023/10/28/ONaClj.jpg" alt="ONaClj.jpg"></p><p>好多单词拼错了、</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-27</title>
    <link href="/blog.github.io/2023/10/27/2023-10-27/"/>
    <url>/blog.github.io/2023/10/27/2023-10-27/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-27</h1><p>早晨听力第二天 ，感觉不错。以后希望都早上听、这个周把第四单元的听力搞完、听力没听完突然知道李克强总理去世了、震惊.jpg</p><h1>Inside view</h1><p>感觉最近听<code>Inside view</code> 简单了一些、也不知道是不是错觉、、、、</p><h3 id="conversation1">conversation1</h3><h4 id="生单词">生单词</h4><p><code>landlord</code> : 房东</p><h3 id="conversation2">conversation2</h3><h4 id="生单词-v2">生单词</h4><p><code>tube </code> ： 地铁、不是管道</p><p><code>frustrating</code> ：沮丧的</p><p><code>borough</code> ： 市镇、地区</p><p><code>vacant</code> ：空缺的</p><p><img src="https://ooo.0x0.ooo/2023/10/27/ONMrFx.jpg" alt="ONMrFx.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-26</title>
    <link href="/blog.github.io/2023/10/26/2023-10-26-%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-26/"/>
    <url>/blog.github.io/2023/10/26/2023-10-26-%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-26/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-26</h1><h2 id="Unit-Test">Unit Test</h2><h3 id="长对话">长对话</h3><p><code>seductive</code> ：诱人的</p><p><code>gaiety</code> : 欢乐</p><h3 id="短文理解">短文理解</h3><p><code>enigmatic</code> ：神秘的高深莫测的</p><h3 id="短篇新闻">短篇新闻</h3><p><code>auction houses</code>  ：拍卖行</p><p><code>considerable</code> : 很大的</p><hr><p><code>quick snapshot</code> ： 快照</p><p><code>the array of books</code> ：很多书</p><p><code>argument </code> -&gt; <code>convincing</code></p><p><code>meantime</code> ：在此时期</p><p><code>Nothing, it's all taken care of. Go relax and watch television.</code>  ：“没事，去玩吧”</p><p><code>blown away.</code> ：被震撼了</p><p><code>synesthesia</code> ：联觉</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-22</title>
    <link href="/blog.github.io/2023/10/22/2023-10-22/"/>
    <url>/blog.github.io/2023/10/22/2023-10-22/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-22</h1><h2 id="Listen-in">Listen in</h2><h3 id="passage-2">passage 2</h3><p><code>tour guide </code> ：导游、没听到的e</p><p><code>phenomena</code> ：现象、没听到</p><p><code>contemporary </code> :当代的</p><p><code>galleries</code> :  美术馆画廊</p><p><code>destinations</code> ： 目的地</p><p><code>renovated</code> : 翻新的</p><p><code>priceless</code> : 无价的</p><p><code>revitalized</code> ：活化</p><p><code>literally</code> ：字面上的</p><p><code> literally revitalized</code> ：焕然一新</p><p><code>metallic</code> : 金属光泽。</p><p><code>curvy</code> ：曲线</p><p><code>futuristic</code> ：未来的 、<code>future</code>  ：未来</p><h2 id="Unit-Test">Unit Test</h2><h3 id="短对话">短对话</h3><p><code>unexplainable</code> ：无法解释</p><p><code>convincing</code> : 令人信服的</p><p><code>frustrating </code>  ： 沮丧的</p><p><code>inviting </code>：吸引人的</p><p><code>Enigmatic</code>: 神秘莫测的</p><p><code> Expressive</code> ：富有表现力的</p><p><code>unstable</code>  ： 不稳定的</p><h3 id="长对话">长对话</h3><p><code>seductive</code> : 诱惑、诱人的</p><p><code>disturbing </code> ：令人不安的</p><p><code>footage</code>  : 镜头</p><p><code>distracting </code> ： 让人分心的</p><p><code>jealousy </code> ：嫉妒</p><p><code>gaiety </code> ： 欢乐</p><p>Uint test 留两段明天听、</p><p><img src="https://ooo.0x0.ooo/2023/10/22/O7YFjM.jpg" alt="O7YFjM.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-21</title>
    <link href="/blog.github.io/2023/10/21/2023%20-10%20-21/"/>
    <url>/blog.github.io/2023/10/21/2023%20-10%20-21/</url>
    
    <content type="html"><![CDATA[<h1>2023 -10 -21</h1><p>倒霉，模型训练太慢，想着做一下U校园,忘记自己翻墙了，还没翻回来、U校园登录异常…。百度说要等半小时之后再重新登录试一下、倒霉</p><h2 id="Listen-in">Listen in</h2><h3 id="new-report-1">new report 1</h3><h4 id="生单词">生单词</h4><p><code>campaign</code> : 运动、战役、一系列比赛、参加（发起）运动</p><p><code>clip</code> : 剪辑</p><p><code>physical</code> ：物理（听不到）</p><p><code>travel</code> ：旅游、听不到</p><p><code>participate</code> ：参与、听不到</p><p><code>audio samples</code> ： 音频样本</p><p><code>sounds</code> ：听不到</p><h3 id="new-report2">new report2</h3><h4 id="生单词-v2">生单词</h4><p><code>reproductive </code>：复制</p><p><code>insulting</code>  : 侮辱</p><p><code>controversial</code> ：有争议的</p><p><code>misrepresenting</code> ： 扭曲</p><h3 id="passage-1-1">passage -1-1</h3><p><code>got</code> ：…没听到</p><p><code>brilliant</code> ：辉煌的</p><p><code>concept</code> ： 概念、观念，不熟</p><p><code> percussion</code> ：打击乐</p><p><code>nephew</code> : 侄子</p><p><code>not quite</code> ：不完全是</p><h3 id="passage-1-2">passage-1-2</h3><p><code>royal</code> ：皇家</p><p><code>reception </code>： 招待会</p><p><code>Fringe Festival</code>： 艺术节</p><h2 id="时间">时间</h2><p><img src="https://ooo.0x0.ooo/2023/10/21/O7ELFj.jpg" alt="O7ELFj.jpg"></p><p>要坚持听听力！！</p><p>今天 <code>1997</code> 这个时间点听到了，感觉不错，但是还有一些的单词，明明是很简单的单词，小学就学的东西，但是听的时候还是听不到…，应该不是说听不到而是“听不懂”，听到这个东西了，但是没想到是&quot;got&quot; 这么简单的…</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-20</title>
    <link href="/blog.github.io/2023/10/20/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-20/"/>
    <url>/blog.github.io/2023/10/20/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-20/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-20</h1><h2 id="Outside-view">Outside view</h2><h3 id="Conversation1">Conversation1</h3><h4 id="生单词">生单词</h4><p><code>gaze</code> :注视、凝视、盯着看</p><p><code>straight </code>：朝、向</p><p><code>represent</code> ：代表</p><p><code>reserved</code> ：含蓄的</p><p><code>self-portrait</code> ：自画像</p><p><code>portrait </code> ：肖像</p><hr><p>re无luation ，变革、革命 ：<code>revolutionary</code></p><p><code>innovation</code> ：创新</p><p><code>adornments</code> : 妆物</p><p><code>imaginary</code> ： 虚构的</p><p><code>For instance</code> : 例如</p><p><code>cover up</code> ：掩盖</p><p><code>speculation</code> ：推测猜测</p><p><code>happier</code> ：<code>happy</code> 的比较级</p><h3 id="Conversation2">Conversation2</h3><h4 id="生单词-v2">生单词</h4><p>这一篇虽然听不懂，但是很好答第一题。</p><p><code>decay</code> ：腐烂的</p><p><code>essence</code> ：木质的</p><p><code>consist </code>：组成</p><p><code>multiples</code> ：倍数</p><p><code>resilience ：复原能力</code></p><h2 id="时间">时间</h2><p><img src="https://ooo.0x0.ooo/2023/10/21/O7RmTl.jpg" alt="O7RmTl.jpg"></p><p>感觉最近状态不对，学东西安静不下心，太乱了 ，心乱，不应该这样的。应该要改的，希望下个周可以改一改。</p><p>乱的原因我感觉应该是目标不坚定，还是不知道自己应该干什么，迷茫又迷惑，清楚又不清楚…</p><p>还是当个混子舒服，舒服但是也不舒服，人总要承担一些责任的。有了一些责任就没有了一些自由…</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-19.md</title>
    <link href="/blog.github.io/2023/10/19/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-md/"/>
    <url>/blog.github.io/2023/10/19/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-md/</url>
    
    <content type="html"><![CDATA[<h1>听力日常 10-19</h1><h2 id="Inside-View">Inside View</h2><h3 id="Conversation-1">Conversation 1</h3><h4 id="生单词">生单词</h4><p><code>chill out</code> ：冷静一下</p><p>这个对话挺容易听懂的，唉听完了六级感觉还是U校园的容易听懂。</p><hr><h3 id="Conversation-2">Conversation 2</h3><h4 id="生单词-v2">生单词</h4><p><code>cabaret</code>  ：(餐馆夜间的)卡巴莱歌舞表演</p><p><code>slightly</code> ：轻微有点</p><p><code>contemporary</code> ：当代的</p><p><code>adult</code> ：认识但是听的不好</p><p><code>I clean forget </code> ：不是忘记打扫，是忘干净了，感觉跟 <code>I completely forgot</code> 差不都。</p><p><code>slipped</code> :悄悄的</p><p><code>You'll forget your own head one day.</code> ：这句太逗了</p><p>对时间、数字的灵敏度不够！听到时间、数字需要思考，没有那么直接的反应出来。</p><h2 id="时间记录">时间记录</h2><p><img src="https://ooo.0x0.ooo/2023/10/19/O7v74l.jpg" alt="O7v74l.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>The_Glass_Castle</title>
    <link href="/blog.github.io/2023/10/16/The_Glass_Castle/"/>
    <url>/blog.github.io/2023/10/16/The_Glass_Castle/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-16+17+18</title>
    <link href="/blog.github.io/2023/10/16/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-16+17/"/>
    <url>/blog.github.io/2023/10/16/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-16+17/</url>
    
    <content type="html"><![CDATA[<h2 id="10月16日">10月16日</h2><p>昨天在实验室搞小程序搞到了十二点，实在没抽出时间（也可能是白天过的太安逸了…，得改！）。</p><p>今天估计只能听一下六级了2022年的12月。</p><p>先听完吧，听完再搞明白。</p><hr><p>85.2逆天了…不能困得迷迷糊糊的时候做听力…</p><hr><h2 id="10月17日">10月17日</h2><p>总结了一下不熟的单词又听了一遍前四段。</p><p>感觉听的时候，首先是读题的过程中只能在脑子里边留一个印象（模糊概念、并没有理解，因为存在生单词），之后开始听了之后也是模糊的概念（通过几个单词和、语气、以及题目的意思来了解整篇文章的意思）之后连懵带猜的选出答案。重点的是当开始读题的时候，我不知道应该是去听题还是去读下一个题的题干…有的时候想着听题，有的时候又感觉要去读题…</p><p>单词的总结写在本上了、、</p><h2 id="10月18日">10月18日</h2><p>1：连读问题，单个单词读的情况下会听到，但是连读的情况下分不清、而且还可能会把两个单词的连读当成一个单词.</p><p>例如</p><p><code>how that</code></p><p><code>visual aspect of food </code> 其中的<code>of</code> 没发音</p><p><code>the</code></p><p><code>encourging</code> 和自己想象中的发音是不一样的。</p><p><code>seeing</code> 也不一样</p><p><code>advertisement</code> 发音也不一样，<code>d</code>没发音</p><p><code>heath</code> <code>h</code> 好像变轻了</p><p><code>emphaisizing </code> 强调</p><p><code>focusing </code> ？？？怎么听成b开头的单词</p><p>2：疑惑点 ：逐句精听和全篇听哪个更好？</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-14</title>
    <link href="/blog.github.io/2023/10/14/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-14/"/>
    <url>/blog.github.io/2023/10/14/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-14/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-14</h1><p>昨天因为完成专业课的作业搞到凌晨1点才搞完，实在是没有时间听听力的，所以只能空一天了…</p><p>今天估计能把<code>U2</code> 的听力听完。所以今天没有选择晚上听听力，而是下午就开始听听力。</p><p>这两天还开始抽空背单词了，毕竟还是感觉词汇量不够高。希望能坚持下去吧，大三了总要坚持做一些事情。</p><p>排名要是保研还是靠后的，要么靠竞赛要么靠成绩了，前两年确实过的太轻松了，太轻松就会出问题。虽然不知道为什么写在听力日常汇总里…，但是听力日常汇总也是日常汇总嘛，还是可以记录一下的。</p><p>这几日一直在焦虑，但是感觉焦虑也没用，还是要做些事情。<code>做下去，总比一直想，要好一点的</code>，专业排在我后边的同学都在转到软工，毕竟转软工就能保了。也不知道自己选择不转是否是正确的，迷茫啊、迷茫啊、、，听听力吧，听听力吧。</p><h2 id="Listening-in">Listening in</h2><h3 id="program1">program1</h3><h4 id="生单词">生单词</h4><p><code>by chance</code> :偶然</p><p><code>suddenly </code> ：突然</p><p><code>bring up</code> :抚养</p><p><code>paraside</code> ：天堂</p><p><code>cows in cowsheds, fields with ponds and a muddy yard full of smelly pigs</code> ：形容农场</p><p><code>extraordinary</code> ：非凡</p><p><code>not one tiny bit.</code> ：一丁点也没有</p><p><code>nostalgia</code> ：怀念</p><hr><h3 id="program2">program2</h3><h4 id="生单词-v2">生单词</h4><p><code>coat rack</code> ：衣帽架</p><p><code>hold hands</code> ：手牵手</p><p><code>supportive</code> ：支持 （听到了，没想到）</p><p><code>apart from </code>： 除…之外（听到了没想到）</p><p><code>angle</code>: 天使 （拼错了…）</p><p><code> red blazer and smart shoes.</code>  ：红色的西装和时尚的皮鞋</p><p><code>bossy</code> ：专横</p><p><code>cross</code> ：有生气的意思吧</p><h2 id="Unit-test">Unit test</h2><h3 id="短对话">短对话</h3><h4 id="生单词-v3">生单词</h4><p><code>harsh</code> ：恶劣的</p><p><code>unattractive</code> ：没有吸引力的</p><p><code> journalist</code> ：记者</p><p><code>bear a resemblance</code></p><p><code> It's easy to miss, so keep an eye out for a large brown house sat back from the road.</code></p><p><code>anthropologist</code></p><p><code>incapable of really appreciating a culture without knowing the language.</code>：</p><p><code>orchestra</code> ：</p><h3 id="长对话">长对话</h3><p><code>willful</code> ： 任性</p><p><code>irresponsible</code> ：不负责任的</p><p><code>remarkably</code> ：不平常的</p><p><code>reluctant </code> ：勉强的不情愿的</p><p><code>demonstrate competence</code> ：展现能力</p><h3 id="短文理解">短文理解</h3><p><code>admiration</code> 钦佩仰慕 （没听到）</p><p><code> fortunate</code> ：幸好庆幸</p><p><code>appreciation</code> ：欣赏</p><h3 id="短篇新闻">短篇新闻</h3><p><code>sentenced</code> ：判刑</p><p><code>jail</code> ：牢狱</p><p><code>drowning</code> ：溺水</p><p><code>court</code> ：法院</p><p><code>sparked global</code> ：全球引发了</p><p><code>sympathy</code> ：同情 （听不懂）</p><p><code>acquitted</code> ：无罪释放</p><p><code>a charge of</code> ：控告</p><p><code>conscious neglect</code>   :故意的</p><h2 id="学习时长">学习时长</h2><p>差不多一个小时多点。<code>Unit test</code>  这次听的比上次快了些了。</p><p>不太好的事情就是还是容易分神，一开始想着都听完在搞别的事情，后来听完<code>Listening in </code>之后去犹豫转不转专业去了…。</p><img src="https://ooo.0x0.ooo/2023/10/14/O7MYDG.jpg" alt="O7MYDG.jpg" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-12</title>
    <link href="/blog.github.io/2023/10/12/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-12/"/>
    <url>/blog.github.io/2023/10/12/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-12/</url>
    
    <content type="html"><![CDATA[<h1>2023-10-12</h1><h2 id="U校园-U2-Outside-view">U校园 U2  Outside view</h2><h3 id="Outside-view">Outside view</h3><p>今天应该是在教室里听一会儿，回宿舍再听一会儿，搞了差不多五个小时的小程序，还是没忍住玩了五个小时的手机，感觉是中午吃饭和晚上吃饭的时候玩的多，还有就是睡前，上床的时候把手机放在桌子上还是有效果的 😩。</p><h4 id="Conversation1">Conversation1</h4><h5 id="生单词">生单词</h5><p><code>UNICEF</code> ：联合国儿童基金会</p><p><code>Kabul</code> ：阿富汗首都喀布尔</p><p><code>Taliban</code> ：塔利班</p><p><code>agency</code> : (听到的但是不知道意思) 代理机构</p><p><code>malnutrition</code> ：营养不良的</p><p>按住剋神 ：<code>education</code></p><p><code>kids</code> 不是 <code>keys</code></p><p><code>medicine</code> ：打错了</p><p><code>known</code> 不是 <code>know</code></p><hr><h4 id="Conversation2">Conversation2</h4><h5 id="生单词-v2">生单词</h5><p><code>presenter</code> ：主持人</p><p><code>engineers</code> : 工程师</p><p><code>notebook</code> 不是<code>no books</code></p><p>夫人四年饭盒热 ：<code>friends and fun here</code></p><p><code>train teachers</code> 不是 <code>try teachers</code></p><p><code>supplies</code> ：供应</p><p><code>enrolle</code> ：注册</p><hr><h3 id="Listening-in">Listening in</h3><h4 id="News-reports">News reports</h4><h5 id="第一篇">第一篇</h5><h6 id="生单词-v3">生单词</h6><p><code>relive</code>  ： 重新经历</p><p><code>viral</code> : 病毒的</p><p><code>go viral </code> ：在互联网走红</p><p><code>selfie</code> ：自拍</p><p><code>beloved</code> ：敬爱的</p><hr><h5 id="第二篇">第二篇</h5><h6 id="生单词-v4">生单词</h6><p><code>rare</code> :  罕见的稀有的</p><p><code>figurine</code> ：人像</p><p><code>nostaigia</code> ：怀旧</p><p><code>recapture</code> ：夺回</p><hr><h3 id="学习时长">学习时长</h3><p><img src="https://ooo.0x0.ooo/2023/10/12/O1jbvx.jpg" alt="O1jbvx.jpg"></p><p>感觉今天的差不多听个两三遍都能听懂个百分之七八十，除去一些小单词和语句的意思确实理解错之外。</p><p>差不多听了一个多小时，<code>Listening in</code> 还是差一点，唉唉唉、困困困  😪 😪 😪 ，真希望有一天能睡24个小时。提交完这个还有一个力扣题没写完… 补一补写完再睡吧。反正明天没有早八…。</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听力日常-10-11</title>
    <link href="/blog.github.io/2023/10/11/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-11/"/>
    <url>/blog.github.io/2023/10/11/%E5%90%AC%E5%8A%9B%E6%97%A5%E5%B8%B8-10-11/</url>
    
    <content type="html"><![CDATA[<p>英语记录</p><h1>2023-10-11</h1><h2 id="U校园-U2-Inside-view">U校园 U2  Inside view</h2><h3 id="Inside-view">Inside view</h3><h4 id="Conversation1">Conversation1</h4><h5 id="生单词">生单词</h5><p><code>dock</code> ：船坞、修船所</p><p><code>ship</code> : 船</p><p><code>go up</code> ：上升</p><p><code>pollute</code> ：污染</p><p><code>cargo</code> ：货物</p><p><code>trendy</code> ：时髦</p><p><code>distinctive</code> ：与众不同的</p><p><code>revolting</code> ：令人作呕的</p><p><code>warehouse</code> : 货舱</p><hr><h4 id="Conversation2">Conversation2</h4><h5 id="生单词-v2">生单词</h5><p><code>studio</code> :工作室</p><p><code>Back in a minute </code> ：马上回来</p><p><code>pround of you </code> ：为你骄傲  （填错的）</p><p><code>Hang on</code> : 稍等一下</p><hr><p>本来想着今天把 <code>OutSide view</code> 也听完，但是太困了…😴 🛌 😪</p><p>就只能听完这些了… 😭 😭</p><p>希望明天能把 <code>OutSide view</code> 和<code>Listening in</code> 听完，之后搞份六级听听 :happy:  。</p><h3 id="学习时长">学习时长</h3><p><img src="https://ooo.0x0.ooo/2023/10/11/O1sPPG.jpg" alt="O1sPPG.jpg"></p><p><code>Conversation1</code> 有点听不懂，所以听了好几遍，听懂了之后再去做后边的就很快了。</p><p><code>Conversation2</code> 听得懂，虽然不是每个单词都听到，但是能把意思听懂的，所以就听的时间短了一点。</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10月上半月汇总</title>
    <link href="/blog.github.io/2023/10/11/10%E6%9C%88%E4%B8%8A%E5%8D%8A%E6%9C%88%E6%B1%87%E6%80%BB/"/>
    <url>/blog.github.io/2023/10/11/10%E6%9C%88%E4%B8%8A%E5%8D%8A%E6%9C%88%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>时隔将近半个月又开始写博客了，这半个月倒是经历了挺多的事情。</p><h4 id="1：数学建模国赛出成绩了—省一">1：数学建模国赛出成绩了—省一</h4><p>结果确实是没想到，不仅没想到还有点意外，论文的完整性确实有的。但是论文的算法确实不多，仅仅的包括了数学规划、聚类模型、OLS最小二乘法。这个成绩很意外的，因为一般数模竞赛需要三个人，我们这次基本我负责的是编程和建模、另一个数学专业的学姐负责的是写论文，其余的那个人（隐身了…）。</p><p>自己在这几天其实做的也不算好，每日最爱干的事情还是睡觉…，建模也没建的多好。没做好的原因可以很坦诚地说，原因是因为自己一开始也没想着能得奖…，唉，如果当初花时间做一下相关性分析，把论文的进一步完整性提高上去就好了。不过后悔也没用了</p><p>但是结果确实很意外，下次参加美赛的时候一定要把握好机会，不要浪费时间，We are all dying！希望美赛能获得M奖吧。</p><h4 id="2：微信小程序开发—还差一部分">2：微信小程序开发—还差一部分</h4><p>一个国庆，整整一个国庆，基本处于一种近乎癫狂的状态，一直在做…，不过好在现在做的差不多了（还差一些关键的部分）。</p><p>这部分的感触很深的事情就是，不要一直把事情放脑子里，应该做下去而不是只是在脑子里构想，有一些事情开始做才会有效，一直在脑子里想是没有用处的。</p><hr><h3 id="下半个月的计划">下半个月的计划</h3><p>很重要的一件事，希望能把每日使用手机的时间降到2小时</p><table><thead><tr><th>事情</th><th>记录状况</th></tr></thead><tbody><tr><td>操作系统</td><td>希望能把rust学完，博客记录</td></tr><tr><td>计算机网络</td><td>上这个课的时候不要睡觉吧，能跟上就好。</td></tr><tr><td>英语方面</td><td>希望每天能写一个博客记录英语学习状况</td></tr><tr><td>算法方面</td><td>希望这十五天之后能把leetcode刷到100题</td></tr><tr><td>数据库方面</td><td>希望能刷20-30道SQL语句</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>半月汇总</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode2tree</title>
    <link href="/blog.github.io/2023/09/29/leetcode2tree/"/>
    <url>/blog.github.io/2023/09/29/leetcode2tree/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ： 二叉树的简单题</p><ol><li><h2 id="94-二叉树的中序遍历-力扣（LeetCode）"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/?envType=study-plan-v2&amp;envId=top-100-liked">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></h2></li></ol><p>题目 ：给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em></p><p>输入 ： <img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom:80%;"></p><p>输入  ：<code>root = [1,null,2,3]</code></p><p>输出 ：  <code>[1,3,2]</code></p><p>代码 ：中序遍历，左子树根右子树，用递归即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindAns</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br>       <span class="hljs-comment">//root为空</span><br>       <span class="hljs-keyword">if</span>(root)&#123;<br>           <span class="hljs-built_in">FindAns</span>(root-&gt;left);<br>           ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>           <span class="hljs-built_in">FindAns</span>(root-&gt;right);<br>       &#125;<br>   &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>      <span class="hljs-built_in">FindAns</span>(root);<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><h2 id="104-二叉树的最大深度-力扣（LeetCode）"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&amp;envId=top-100-liked">104. 二叉树的最大深度 - 力扣（LeetCode）</a></h2></li></ol><p>题目 ： 给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img" style="zoom:80%;"><p>输入 ： <code>root = [3,9,20,null,null,15,7]</code></p><p>输出 ： <code>3</code></p><p>代码 ：当前二叉树的深度等于左子树的深度和右子树的深度的最大值加一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">depth</span>(root-&gt;left),<span class="hljs-built_in">depth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">depth</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li><h2 id="226-翻转二叉树-力扣（LeetCode）"><a href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&amp;envId=top-100-liked">226. 翻转二叉树 - 力扣（LeetCode）</a></h2></li></ol><p>题目 ： 给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" style="zoom:80%;"><p>输入 ： <code>root = [4,2,7,1,3,6,9]</code></p><p>输出 ： <code>[4,7,2,9,6,3,1]</code></p><p>代码  ： 从二叉树的上至下利用中间值t进行递归翻转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root)&#123;<br>            TreeNode *t=root-&gt;left;<br>            root-&gt;left=root-&gt;right;<br>            root-&gt;right=t;<br>            <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>            <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode121</title>
    <link href="/blog.github.io/2023/09/29/leetcode121/"/>
    <url>/blog.github.io/2023/09/29/leetcode121/</url>
    
    <content type="html"><![CDATA[<p>题目来源  ： <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?envType=study-plan-v2&amp;envId=top-100-liked">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p><p>题目 ： 给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code></p><p>输入 ： <code>[7,1,5,3,6,4]</code></p><p>输出  :  <code>5</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>       <span class="hljs-comment">//如果股票在第i天卖出，则一定会在第i天之前的价格最少的一天卖出</span><br>       <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> min=<span class="hljs-number">10001</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>           <span class="hljs-keyword">if</span>(min&gt;prices[i])&#123;<br>               min=prices[i];<br>           &#125;<br>           <span class="hljs-keyword">if</span>(ans&lt;(prices[i]-min))&#123;<br>               ans=(prices[i]-min);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>思路就是利用贪心的思想，如果股票在第 <code>i</code> 天卖出，那么可以肯定的是股票购买的价格一定是第 <code>i</code> 天以前的价格最低的那天，所以通过一层循环，既可以得出答案。在循环的过程中不断进行更新最小的价格和答案。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode605</title>
    <link href="/blog.github.io/2023/09/29/leetcode605/"/>
    <url>/blog.github.io/2023/09/29/leetcode605/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/can-place-flowers/">605. 种花问题 - 力扣（LeetCode）</a></p><p style="color :red;">难度 ： 简单 </p><p>题目 ： 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p><p>输入 ： <code>flowerbed = [1,0,0,0,1], n = 1</code></p><p>输出  ： <code>true</code></p><p>代码 ：</p><p>先对花园的<code>首</code> 、<code>尾</code> 进行判断，之后在内部数0的个数，如果两个<code>1</code> 之间是奇数个<code>0</code> 那么就是<code>count/2</code> 如果是偶数个<code>0</code> 那么就是 <code>count/2-1</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> start = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; flowerbed[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>            n -= <span class="hljs-number">1</span>;<br>            flowerbed[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flowerbed.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; flowerbed[flowerbed.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[flowerbed.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>] == <span class="hljs-number">0</span>) &#123;<br>            n -= <span class="hljs-number">1</span>;<br>            flowerbed[flowerbed.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flowerbed.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; n == <span class="hljs-number">1</span>) || n == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; flowerbed.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (flowerbed[i] == <span class="hljs-number">1</span> &amp;&amp; start == <span class="hljs-literal">false</span>) &#123;<br>                count = <span class="hljs-number">0</span>;<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flowerbed[i] == <span class="hljs-number">0</span>&amp;&amp;start==<span class="hljs-literal">true</span>) &#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flowerbed[i] == <span class="hljs-number">1</span> &amp;&amp; start == <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                        n -= (count / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        n -= (count / <span class="hljs-number">2</span>);<br>                    &#125;<br>                &#125;<br>                start = <span class="hljs-literal">false</span>;<br>                i -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode15</title>
    <link href="/blog.github.io/2023/09/28/leetcode15/"/>
    <url>/blog.github.io/2023/09/28/leetcode15/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ： <a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&amp;envId=top-100-liked">15. 三数之和 - 力扣（LeetCode）</a></p><p style="color :red"> 难度 ： 中等 </p><p>题目 ： 给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><p>输入 : <code>nums = [-1,0,1,2,-1,-4]</code></p><p>输出 ： <code>[[-1,-1,2],[-1,0,1]]</code></p><p>思路 ：因为昨天做了个用双指针的水桶的题，所以做这个题一开始也想直接用双指怎。先对数组进行排序，之后利用一个指针i指向的是开始、指针j指向的是末尾。利用指针k进行遍历中间的元素也就是双层循环就可以，但是逻辑是有漏洞的因为当<code>nums[i]+nums[j]+nums[k]=0</code> 的时候你是不知道应该怎么移动指针的。所以需要更改代码。改来改去感觉这个思路不太对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//漏洞代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;,<span class="hljs-type">int</span>&gt;HashTable;    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//按照惯例先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; t;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>            <span class="hljs-type">int</span> a = nums[i] + nums[j];<br>            t.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; k &lt;= j - <span class="hljs-number">1</span>; k++) &#123;<br>                <span class="hljs-keyword">if</span> ((a + nums[k]) == <span class="hljs-number">0</span>) &#123;<br>                    t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                    t.<span class="hljs-built_in">push_back</span>(nums[j]);<br>                    t.<span class="hljs-built_in">push_back</span>(nums[k]);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-keyword">if</span>(HashTable[t]!=<span class="hljs-number">1</span>)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(t);<br>                    HashTable[t]=<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">//这里是不对的。</span><br>                i++;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//没问题</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) &#123;<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    j--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>于是重新想了一个思路，两个数相加等于0不就说明，其中的两个数相加等于另外一个数的相反数。改啊改啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt;HashTable;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//按照惯例先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//外层循环</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        vector&lt;<span class="hljs-type">int</span>&gt; t;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            t.<span class="hljs-built_in">clear</span>();<br>            t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-type">int</span> a = nums[i];<br>            j = i + <span class="hljs-number">1</span>;<br>            k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                b = nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (b + a == <span class="hljs-number">0</span> &amp;&amp; j != i &amp;&amp; k != i) &#123;<br>                    t.<span class="hljs-built_in">push_back</span>(nums[j]);<br>                    t.<span class="hljs-built_in">push_back</span>(nums[k]);<br>                    j = i + <span class="hljs-number">1</span>;<br>                    k--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (b + a &lt; <span class="hljs-number">0</span>) &#123;<br>                        j++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        k--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>                <span class="hljs-keyword">if</span> (HashTable[t] != <span class="hljs-number">1</span> &amp;&amp; t.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(t);<br>                    HashTable[t] = <span class="hljs-number">1</span>;<br>                    t.<span class="hljs-built_in">clear</span>();<br>                    t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;<br>                    t.<span class="hljs-built_in">clear</span>();<br>                    t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>最后在300个测试样例的时候超时了，真是遗憾啊，差一点就过了…。</p><p>继续改啊改啊，终于过了…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt;HashTable;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//按照惯例先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//外层循环</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        vector&lt;<span class="hljs-type">int</span>&gt; t;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            t.<span class="hljs-built_in">clear</span>();<br>            t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-type">int</span> a = nums[i];<br>            j = i + <span class="hljs-number">1</span>;<br>            k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                b = nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (b + a == <span class="hljs-number">0</span> &amp;&amp; j != i &amp;&amp; k != i) &#123;<br>                    t.<span class="hljs-built_in">push_back</span>(nums[j]);<br>                    t.<span class="hljs-built_in">push_back</span>(nums[k]);<br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-type">int</span> l=nums[j];<br>                    <span class="hljs-keyword">while</span>(nums[j]==k)&#123;<br>                        j++;<br>                    &#125;<br>                    k--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (b + a &lt; <span class="hljs-number">0</span>) &#123;<br>                        j++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        k--;<br>                    &#125;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">size</span>()==<span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>                    <span class="hljs-keyword">if</span>(HashTable[t]!=<span class="hljs-number">1</span>)&#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(t);<br>                        HashTable[t]=<span class="hljs-number">1</span>;<br>                    &#125;<br>                    t.<span class="hljs-built_in">clear</span>();<br>                    t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>因为今天去看了奥本海默所以只做这么一道题吧…</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode1333</title>
    <link href="/blog.github.io/2023/09/27/leetcode1333/"/>
    <url>/blog.github.io/2023/09/27/leetcode1333/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ： <a href="https://leetcode.cn/problems/filter-restaurants-by-vegan-friendly-price-and-distance/description/?envType=daily-question&amp;envId=2023-09-27">1333. 餐厅过滤器 - 力扣（LeetCode）</a></p><p style="color :red"> 难度 ：中等 </p><p>题目 ：给你一个餐馆信息数组 <code>restaurants</code>，其中 <code>restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]</code>。你必须使用以下三个过滤器来过滤这些餐馆信息。</p><p>其中素食者友好过滤器 <code>veganFriendly</code> 的值可以为 <code>true</code> 或者 <code>false</code>，如果为 <em>true</em> 就意味着你应该只包括 <code>veganFriendlyi</code> 为 true 的餐馆，为 <em>false</em> 则意味着可以包括任何餐馆。此外，我们还有最大价格 <code>maxPrice</code> 和最大距离 <code>maxDistance</code> 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。</p><p>过滤后返回餐馆的 *<strong>id*</strong>，按照 <em><strong>rating</strong></em> 从高到低排序。如果 <em><strong>rating</strong></em> 相同，那么按 <em><strong>id</strong></em> 从高到低排序。简单起见， <code>veganFriendlyi</code> 和 <code>veganFriendly</code> 为 <em>true</em> 时取值为 <em>1</em>，为 <em>false</em> 时，取值为 <em>0 。</em></p><p>输入：<code>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10</code><br>输出：<code>[3,1,5] </code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//需要注意这里的类型需要是static</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,vector&lt;<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]&gt;b[<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]==b[<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">filterRestaurants</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; restaurants, <span class="hljs-type">int</span> veganFriendly, <span class="hljs-type">int</span> maxPrice, <span class="hljs-type">int</span> maxDistance)</span> </span>&#123;<br>        <span class="hljs-comment">//先进行排序</span><br>        <span class="hljs-built_in">sort</span>(restaurants.<span class="hljs-built_in">begin</span>(),restaurants.<span class="hljs-built_in">end</span>(),cmp);<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>          vector&lt;<span class="hljs-type">int</span>&gt; t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;restaurants.<span class="hljs-built_in">size</span>();i++)&#123;<br>            t=restaurants[i];<br>            <span class="hljs-keyword">if</span>(veganFriendly==<span class="hljs-number">1</span>)&#123;<br>                 <span class="hljs-keyword">if</span>(t[<span class="hljs-number">2</span>]==veganFriendly&amp;&amp;t[<span class="hljs-number">3</span>]&lt;=maxPrice&amp;&amp;t[<span class="hljs-number">4</span>]&lt;=maxDistance)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(t[<span class="hljs-number">0</span>]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                 <span class="hljs-keyword">if</span>(t[<span class="hljs-number">3</span>]&lt;=maxPrice&amp;&amp;t[<span class="hljs-number">4</span>]&lt;=maxDistance)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(t[<span class="hljs-number">0</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先排序，再遍历找满足条件的即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode11</title>
    <link href="/blog.github.io/2023/09/27/leetcode11/"/>
    <url>/blog.github.io/2023/09/27/leetcode11/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a><br>题目 ：给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>**说明：**你不能倾斜容器。</p><p>输入 ： <code>[1,8,6,2,5,4,8,3,7]</code></p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" style="zoom:80%;"><p>输出 ： <code>49</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;height.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(ans&lt;(<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i)))&#123;<br>                    ans=(<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一开始第一眼，确实想到了直接套两层循环就直接得出结果了。但是结果确实可想而知，超出时间限制了…</p><img src="https://img1.imgtp.com/2023/09/27/23EdrEv3.jpg" alt="leetcode11outtime.jpg" style="zoom:80%;"><p>继续优化呀，优化呀…</p><p>想啊，想啊，想啊，一根烟，一瓶水，一道力扣想一天…。</p><p>终于看了K神的题解，原来用双指针就可以解决这个问题…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i!=j)&#123;<br>            <span class="hljs-keyword">if</span>(ans&lt;(<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i)))&#123;<br>                ans=<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(height[i]&lt;height[j])&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>        &#125;<br>          <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode142</title>
    <link href="/blog.github.io/2023/09/27/leetcode142/"/>
    <url>/blog.github.io/2023/09/27/leetcode142/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&amp;envId=top-100-liked">142. 环形链表 II - 力扣（LeetCode）</a></p><p>题目 ：给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。<strong>不允许修改</strong> 链表。</p><p>输入 ： <code>head = [3,2,0,-4], pos = 1</code></p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:80%;"><p>输出 ： <code>返回索引为 1 的链表节点</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;ListNode *,<span class="hljs-type">int</span>&gt; HashTable;<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *p1=head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(HashTable[p1]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> p1;<br>                &#125;<br>                HashTable[p1]=<span class="hljs-number">1</span>;<br>                p1=p1-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>继续使用哈希表…</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode141</title>
    <link href="/blog.github.io/2023/09/26/leetcode141/"/>
    <url>/blog.github.io/2023/09/26/leetcode141/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ： <a href="https://leetcode.cn/problems/linked-list-cycle/?envType=study-plan-v2&amp;envId=top-100-liked">141. 环形链表 - 力扣（LeetCode）</a></p><p>题目 ： 给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p>输入 ： <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:80%;"></p><p><code>head = [3,2,0,-4], pos = 1</code></p><p>输出 <code>true</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;ListNode *,<span class="hljs-type">int</span>&gt; HashTable;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *p1=head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(HashTable[p1]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                HashTable[p1]=<span class="hljs-number">1</span>;<br>                p1=p1-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用哈希表…哈希表真是个好东西！</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode169</title>
    <link href="/blog.github.io/2023/09/26/leetcode169/"/>
    <url>/blog.github.io/2023/09/26/leetcode169/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：</p><p style="color :red;">难度 ：简单</p><p>题目 ： 给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>输入 ：<code>nums = [3,2,3]</code></p><p>输出：<code>3</code></p><p>思路 1：利用哈希表即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//用哈希表</span><br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;HashTable;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            HashTable[nums[i]]++;<br>            <span class="hljs-keyword">if</span>(HashTable[nums[i]]&gt;nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode206</title>
    <link href="/blog.github.io/2023/09/26/leetcode206/"/>
    <url>/blog.github.io/2023/09/26/leetcode206/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：</p><p style="color :red;">难度 ：简单</p><p>题目 ：给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" style="zoom: 80%;"><p>输入 ：<code>head = [1,2,3,4,5]</code></p><p>输出：<code>[5,4,3,2,1]</code></p><p>思路 1：用三个指向链表的指针即可以完成这个过程。但是代码出现一个问题，很奇怪的问题。循环结束之后<code>p</code>指向的是倒数第二个节点，<code>q</code> 指向的是最后一个结点，但是我发现如果直接将 <code>q-&gt;next=p</code> 会出错。想到为什么会出错了，因为如果针对的是两个结点的链表将<code>p-&gt;next=q</code>那么会造成一个循环链表这样一定会出现错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//链表反转</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;next-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            ListNode *p=head;<br>            ListNode *q=p-&gt;next;<br>            ListNode *t =q-&gt;next;<br>            <span class="hljs-keyword">while</span>(t)&#123;<br>                <span class="hljs-keyword">if</span>(p==head)&#123;<br>                    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>                &#125;<br>                q-&gt;next=p;<br>                p=q;<br>                q=t;<br>                t=t-&gt;next;<br>            &#125;<br>            ListNode *ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>            ans-&gt;val=q-&gt;val;<br>            ans-&gt;next=p;<br>            <span class="hljs-keyword">return</span>  ans;<br>        &#125; <br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> val=head-&gt;next-&gt;val;<br>            head-&gt;next-&gt;val=head-&gt;val;<br>            head-&gt;val=val;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>改进版代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 链表反转</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 空链表或只有一个节点，无需反转</span><br>        &#125;<br><br>        ListNode *prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode *current = head;<br>        <br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode *nextNode = current-&gt;next;<br>            current-&gt;next = prev;<br>            prev = current;<br>            current = nextNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev; <span class="hljs-comment">// prev 指向新的链表头</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode160</title>
    <link href="/blog.github.io/2023/09/26/leetcode160/"/>
    <url>/blog.github.io/2023/09/26/leetcode160/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&amp;envId=top-100-liked">160. 相交链表 - 力扣（LeetCode）</a></p><p style="color :red;">难度 ：简单</p><p>题目 ： 给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="160_statement.png (742×241) (leetcode-cn.com)" style="zoom:80%;"><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p>输入 ：<code>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</code></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img" style="zoom:80%;"></a></p><p>输出：<code>Intersected at '8'</code></p><p>思路 ：这个题是很简单的，直接对两个链表进行遍历，找到相等的点即可。但是一开始确实一直出错，请看代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *p=headA;<br>        ListNode *q=headB;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>)&#123;<br>            q=headB;<br>            <span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">if</span>(p==q)&#123;<br>                    <span class="hljs-keyword">return</span> p;<br>                &#125;<br>                q=q-&gt;next;<br>            &#125;<br>            p=p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>不知道你们看出来没有，其实错误点在于第一层循环居然用的两个链表都是非空的情形，这这个错误导致最后只进行了一层循环。</p><p>改成 <code>while(p!=NULL)</code>即可。</p><p>代码 2： 其实这个也是按照于链表的遍历，但是相较于第一种偏向于同时进行循环遍历，即不再是嵌套循环而是<code>两个圈子一起循环</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *p1 = headA;<br>        ListNode *p2 = headB;<br>        <span class="hljs-comment">// 遍历链表直到相交或同时到达末尾</span><br>        <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>            p1 = (p1 != <span class="hljs-literal">NULL</span>) ? p1-&gt;next : headB;<br>            p2 = (p2 != <span class="hljs-literal">NULL</span>) ? p2-&gt;next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1; <span class="hljs-comment">// 返回交点或NULL</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode128</title>
    <link href="/blog.github.io/2023/09/24/leetcode128/"/>
    <url>/blog.github.io/2023/09/24/leetcode128/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&amp;envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p><p style="color :red"> 难度 ：中等</p><p>题目 ： 给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p>输入 ： <code>nums = [100,4,200,1,3,2]</code></p><p>输出 ： <code>4</code></p><p>解释 ： <code>最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//去重代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;HashTable;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//去重</span><br>       vector&lt;<span class="hljs-type">int</span>&gt; t;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>           <span class="hljs-keyword">if</span>(HashTable[nums[i]]!=<span class="hljs-number">1</span>)&#123;<br>               t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>           &#125;<br>           HashTable[nums[i]]=<span class="hljs-number">1</span>;<br>       &#125;<br>        nums=t;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]+<span class="hljs-number">1</span>==nums[i+<span class="hljs-number">1</span>])&#123;<br>                ans++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(max&lt;ans)&#123;<br>                    max=ans;<br>                &#125;<br>                ans=<span class="hljs-number">0</span>;<br>            &#125; <br>        &#125;<br>        max=max&gt;ans?max:ans;<br>        <span class="hljs-keyword">return</span> max+<span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//不去重代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;HashTable;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]+<span class="hljs-number">1</span>==nums[i+<span class="hljs-number">1</span>])&#123;<br>                ans++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]==nums[i+<span class="hljs-number">1</span>])&#123;<br>                ans=ans;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(max&lt;ans)&#123;<br>                    max=ans;<br>                &#125;<br>                ans=<span class="hljs-number">0</span>;<br>            &#125; <br>        &#125;<br>        max=max&gt;ans?max:ans;<br>        <span class="hljs-keyword">return</span> max+<span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路 ：先利用<code>sort</code> 函数进行排序，之后利用<code>HashTable</code> 来去重，之后遍历查找最大的即可。还可以不去重，则在遍历的时候判断是否存在重的可能。</p><img src="https://img1.imgtp.com/2023/09/24/1fzaDTMt.png" alt="leetcode128ac.png" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode49</title>
    <link href="/blog.github.io/2023/09/24/leetcode49/"/>
    <url>/blog.github.io/2023/09/24/leetcode49/</url>
    
    <content type="html"><![CDATA[<p>题目来源 ：<a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&amp;envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p><p style="color :red;">难度 ： 中等</p><p>题目 :给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p>输入: <code>strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code></p><p>输出:<code>[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</code></p><p>代码:</p><p style="color :red">代码1</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;string ,<span class="hljs-type">int</span>&gt; HashTable;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>      vector&lt;string&gt; tt;<br>      vector&lt;string&gt; t;<br>      vector&lt;vector&lt;string&gt;&gt; ans;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.<span class="hljs-built_in">size</span>();i++)&#123;<br>          tt.<span class="hljs-built_in">push_back</span>(strs[i]);<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tt.<span class="hljs-built_in">size</span>();i++)&#123;<br>          <span class="hljs-built_in">sort</span>(tt[i].<span class="hljs-built_in">begin</span>(),tt[i].<span class="hljs-built_in">end</span>());<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tt.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(tt[i]!=<span class="hljs-string">&quot;A&quot;</span>)&#123;<br>                HashTable.<span class="hljs-built_in">clear</span>();<br>                HashTable[tt[i]]=<span class="hljs-number">1</span>;<br>                t.<span class="hljs-built_in">clear</span>();<br>                t.<span class="hljs-built_in">push_back</span>(strs[i]);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;tt.<span class="hljs-built_in">size</span>();j++)&#123;<br>                    <span class="hljs-keyword">if</span>(HashTable[tt[j]]==<span class="hljs-number">1</span>)&#123;<br>                        t.<span class="hljs-built_in">push_back</span>(strs[j]);<br>                        tt[j]=<span class="hljs-string">&quot;A&quot;</span>;<br>                    &#125;<br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(t);<br>            &#125;   <br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路1 :利用哈希表和一个辅助的 <code>string</code> 数组 <code>tt</code>，<code>tt</code>用来存储的是字母已经被排过顺序的字符串数组。其中利用<code>tt</code> 来构建哈希表，之后通过哈希表和双层循环来找出一组<strong>字母异位词</strong>的数组。但是因为时间复杂度太高，导致并没有通过<code>leetcode</code>。</p><img src="https://img1.imgtp.com/2023/09/24/BRg0FSpR.png" alt="leetcode49outtimepng.png" style="zoom: 67%;"><p style="color :blue;">代码2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;string ,<span class="hljs-type">int</span>&gt; HashTable;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>      vector&lt;string&gt; tt;<br>      vector&lt;string&gt; t;<br>      vector&lt;vector&lt;string&gt;&gt; ans;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.<span class="hljs-built_in">size</span>();i++)&#123;<br>          tt.<span class="hljs-built_in">push_back</span>(strs[i]);<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tt.<span class="hljs-built_in">size</span>();i++)&#123;<br>          <span class="hljs-built_in">sort</span>(tt[i].<span class="hljs-built_in">begin</span>(),tt[i].<span class="hljs-built_in">end</span>());<br>      &#125;<br>      vector&lt;string&gt;::iterator to;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tt.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(tt[i]!=<span class="hljs-string">&quot;A&quot;</span>)&#123;<br>                t.<span class="hljs-built_in">clear</span>();<br>                t.<span class="hljs-built_in">push_back</span>(strs[i]);<br>                to=tt.<span class="hljs-built_in">begin</span>();<br>                string a=tt[i];<br>                tt[i]=<span class="hljs-string">&quot;A&quot;</span>;<br>                <span class="hljs-keyword">while</span>(to!=tt.<span class="hljs-built_in">end</span>())&#123;<br>                    to=<span class="hljs-built_in">find</span>(tt.<span class="hljs-built_in">begin</span>(),tt.<span class="hljs-built_in">end</span>(),a);<br>                    <span class="hljs-keyword">if</span>(to!=tt.<span class="hljs-built_in">end</span>())&#123;<br>                        t.<span class="hljs-built_in">push_back</span>(strs[to-tt.<span class="hljs-built_in">begin</span>()]);<br>                        *to=<span class="hljs-string">&quot;A&quot;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(t);<br>            &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路2 :利用<code>vector</code> 的<code>find</code> 函数减少一些运算。</p><img src="https://img1.imgtp.com/2023/09/24/6Uljzvd8.png" alt="leetcode49ac.png" style="zoom: 80%;">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode136</title>
    <link href="/blog.github.io/2023/09/23/leetcode136/"/>
    <url>/blog.github.io/2023/09/23/leetcode136/</url>
    
    <content type="html"><![CDATA[<p>题目来源  ： <a href="https://leetcode.cn/problems/single-number/?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><p style="color :red;">难度 ：简单</p><p>题目 ：给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>输入 ： <code>nums = [2,2,1]</code></p><p>输出 ： <code>1</code></p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; HashTable;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            HashTable[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(HashTable[nums[i]]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路 ：</p><p>利用哈希表，时间复杂度<code>O(n)</code> 空间复杂度 <code>O(n)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVST</title>
    <link href="/blog.github.io/2023/09/23/CVST/"/>
    <url>/blog.github.io/2023/09/23/CVST/</url>
    
    <content type="html"><![CDATA[<h1>MATLAB 计算机视觉实战</h1><p>这是一本由 赵小川、何灏、唐弘毅 编著的一本关于MATLAB计算机视觉实战的一本书。</p><p>由清华大学出版社出版，售价49元</p><p>从MATLAB基础和数字图像处理开始，基于系统对象的编程、模块化仿真、C/C++代码生成、双目立体视觉及其程序实现。</p><h2 id="第一章MATLAB操作基础">第一章MATLAB操作基础</h2><h3 id="1-1矩阵操作与运算">1.1矩阵操作与运算</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%%行向量、列向量、矩阵</span><br>a=[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] <span class="hljs-comment">%a=[1,2,3]</span><br>a=<br>[<span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span>]<br><span class="hljs-comment">%a=[1;2;3]</span><br>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<span class="hljs-comment">%a=[1 2 3;4 5 6;7 8 9]</span><br><br><span class="hljs-comment">%%特殊矩阵的生成函数</span><br><span class="hljs-built_in">ones</span>(n) <span class="hljs-comment">%生成n*n的全1矩阵</span><br><span class="hljs-built_in">ones</span>(m,n,....p)<span class="hljs-comment">%生成n*m*...*p的全1矩阵</span><br><span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(A))<span class="hljs-comment">%生成一个与矩阵A同样大小的全1矩阵</span><br><span class="hljs-built_in">zeros</span>(n) <span class="hljs-comment">%生成n*n的全0矩阵</span><br><span class="hljs-built_in">zeros</span>(n,m,.....p)<span class="hljs-comment">%生成n*m*...*p的全0矩阵</span><br><span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(A))<span class="hljs-comment">%生成与A大小相同的全0元素矩阵</span><br><span class="hljs-built_in">eye</span>(n) <span class="hljs-comment">%创建一个大小为n*n的单位矩阵</span><br><span class="hljs-built_in">eye</span>(n,m...p)<span class="hljs-comment">%创建一个大小为n*m*....*p的单位矩阵</span><br><span class="hljs-built_in">eye</span>(<span class="hljs-built_in">size</span>(A))<span class="hljs-comment">%创建一个大小与A同样的单位矩阵</span><br><span class="hljs-built_in">magic</span>(n) <span class="hljs-comment">%生成的每一行，每一列的和都相等</span><br><span class="hljs-built_in">rand</span>(n)<span class="hljs-comment">%生成一个n*n的正态分布随机矩阵，其元素均为0均值，单位方差的正态分布的随机数</span><br><span class="hljs-built_in">rand</span>(n)<span class="hljs-comment">%生成的为随机数矩阵，其元素为0-1的均有分布</span><br><span class="hljs-built_in">diag</span>(x)<span class="hljs-comment">%创建一个n维的对角仿真，主对角线取值为向量x，其余元素均为0</span><br><span class="hljs-built_in">triu</span>(A) <span class="hljs-comment">%创建一个与矩阵A大小相同的上三角矩阵，其中的主对角线元素为A上的对应的元素。</span><br><span class="hljs-built_in">tril</span>(A) <span class="hljs-comment">%创建一个与矩阵A大小相同的下三角矩阵，其中的主对角线元素为A中相应的元素，其余为0</span><br><br><span class="hljs-comment">%% 矩阵的变形操作</span><br><span class="hljs-built_in">fliplr</span>(A) <span class="hljs-comment">%逆序排列矩阵A的每一行</span><br><span class="hljs-built_in">flipud</span>(A) <span class="hljs-comment">%逆序排列矩阵A的每一列</span><br><span class="hljs-built_in">flipdim</span>(A,dim) <span class="hljs-comment">%生成一个在第dim维矩阵A内的元素交换位置的多维矩阵,n为1的时候在行上，n为2的时候在列上?</span><br><span class="hljs-built_in">rot90</span>(A) <span class="hljs-comment">%生成一个由矩阵A逆时针旋转90°而得到的新矩阵</span><br><span class="hljs-built_in">reshape</span>(A,m,n) <span class="hljs-comment">%生成一个m*n维的矩阵，其元素以线性索引的方式从矩阵A中顺序取得，其中的元素个数需要相同</span><br><span class="hljs-built_in">cat</span>(dim,A,B) <span class="hljs-comment">%将矩阵A与矩阵B在dim个维度上拼接成新的矩阵</span><br><span class="hljs-built_in">permute</span>(A,order) <span class="hljs-comment">%根据向量order改变矩阵A中的维数顺序</span><br><span class="hljs-built_in">ipermute</span>(A,order) <span class="hljs-comment">%进行permute命令的逆变换</span><br><span class="hljs-built_in">sort</span>(A) <span class="hljs-comment">%对一维或者二维矩阵进行升序排列，并返回排序后的矩阵，当A是二维矩阵，对矩阵A的每一列分别进行排序。</span><br><br><span class="hljs-comment">%%矩阵的下标引用</span><br><span class="hljs-comment">%matlab中的矩阵是按照列索引的，分为单索引和双索引</span><br>A(n) <span class="hljs-comment">%通过单索引的方式找到一个数值</span><br>A(:,n) <span class="hljs-comment">%第n列</span><br>A(<span class="hljs-built_in">i</span>,:) <span class="hljs-comment">%第i行</span><br>A(:,m:n) <span class="hljs-comment">%第m列到第n列</span><br>A(<span class="hljs-built_in">i</span>:<span class="hljs-built_in">j</span>,:) <span class="hljs-comment">%第i行到第j行</span><br>A(<span class="hljs-built_in">i</span>:<span class="hljs-built_in">j</span>,m:n)<span class="hljs-comment">%第i行到第j行和第m列到第n列的交集</span><br>A(:) <span class="hljs-comment">%返回一个由矩阵A所有的列向量拼接而成的列向量</span><br>A(<span class="hljs-built_in">i</span>:<span class="hljs-built_in">j</span>) <span class="hljs-comment">%返回一个A(:)中的第i行到第j行转置的行向量。</span><br>A([i1 i2]) <span class="hljs-comment">%返回A(:)中的il、i2中的元素组成的行向量</span><br>A(:,[m1 m2 ...]) <span class="hljs-comment">%返回的一个是由矩阵A的第m1,m2等列向量构成的子矩阵。</span><br>A([i1 i2],:) <span class="hljs-comment">%返回的是由矩阵A中第i1、i2等行向量构成的子矩阵</span><br>A([i1 i2],[m1,m2]) <span class="hljs-comment">%返回矩阵A中第il,i2等行向量和第m1、m2等构成的列向量。</span><br><br><span class="hljs-comment">%%获取矩阵的信息</span><br><span class="hljs-built_in">isempty</span>(A) <span class="hljs-comment">%是否为空</span><br><span class="hljs-built_in">isscalar</span>(A) <span class="hljs-comment">%是否是单元素标量矩阵</span><br><span class="hljs-built_in">isvector</span>(A) <span class="hljs-comment">%是否是行向量或者是列向量</span><br>issparse(A) <span class="hljs-comment">%是否是稀疏矩阵</span><br><span class="hljs-built_in">ndims</span>(A) <span class="hljs-comment">%获取矩阵A的维数</span><br><span class="hljs-built_in">size</span>(A) <span class="hljs-comment">%获取矩阵A的尺寸</span><br><span class="hljs-built_in">length</span>(A) <span class="hljs-comment">%获取矩阵A的最长的维度长度</span><br><span class="hljs-built_in">numel</span>(A) <span class="hljs-comment">%获取元素的个数</span><br><br><br><span class="hljs-comment">%%矩阵的运算</span><br><span class="hljs-comment">%乘法运算和除法运算都需要满足格式上的需求、方阵才可以使用幂运算</span><br><span class="hljs-comment">%需要注意的是 .* 和 *是不一样的 *相对于矩阵来说是矩阵的运算，而.*相当于对应的数值相乘。同理/也适用</span><br>det(A) <span class="hljs-comment">%矩阵的转置</span><br>inv(A) <span class="hljs-comment">%矩阵的逆</span><br>rank(A) <span class="hljs-comment">%矩阵的秩</span><br>eig(A) <span class="hljs-comment">%矩阵的特征值</span><br>A=<span class="hljs-built_in">rand</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br>B=<span class="hljs-built_in">ones</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br>C=A&gt;B <span class="hljs-comment">%其中矩阵C中为1代表A中这个位置的值大于B中这个位置的值。</span><br><span class="hljs-comment">%%同理&lt; &lt;= ~=(不等关系) 以及逻辑运算 &amp; | xor not</span><br><br><span class="hljs-comment">%%取整运算</span><br><span class="hljs-built_in">floor</span>(A) <span class="hljs-comment">%正无穷取整</span><br><span class="hljs-built_in">ceil</span>(A) <span class="hljs-comment">%负无穷取整</span><br><span class="hljs-built_in">round</span>(A) <span class="hljs-comment">%A中按照最接近的整数取整即四舍五入</span><br><span class="hljs-built_in">fix</span>(A) <span class="hljs-comment">%按照离0近的方向取整</span><br><br><span class="hljs-comment">%%矩阵的分解</span><br>[L,U]=lu(X) <span class="hljs-comment">%对X矩阵进行LU 分解</span><br>[Q,R]=qr(X) <span class="hljs-comment">%对矩阵X进行QR分解</span><br><br><span class="hljs-comment">%%查找最值与查找值</span><br><span class="hljs-built_in">max</span>(A) <span class="hljs-comment">%取矩阵A的每一列最大值，组成行向量</span><br><span class="hljs-built_in">max</span>(A,B) <span class="hljs-comment">%取矩阵A和B所对应位置上的最大值</span><br><span class="hljs-built_in">max</span>(A,[],dim) <span class="hljs-comment">% dim等于1 时候为max(A) ,dim等于2的时候为矩阵A的每一行最大值组成列向量</span><br><span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(A)) <span class="hljs-comment">%取矩阵A的最大值</span><br><br>ind= <span class="hljs-built_in">find</span>(X) <span class="hljs-comment">%返回单索引下标</span><br>[m n]=<span class="hljs-built_in">find</span>(X) <span class="hljs-comment">%返回双索引下标 </span><br></code></pre></td></tr></table></figure><hr><h3 id="1-2MATLAB编程基础">1.2MATLAB编程基础</h3><p>针对这部分的编程基础中的<code>if</code> <code>else</code>  <code>for </code> <code>while</code> 其实是和C语言C++语言等一般语言是差不多的，只是结束的时候需要<code>end</code>。</p><p>而matlab中特殊的地方就是</p><blockquote><p>函数句柄、匿名函数</p></blockquote><h4 id="函数句柄">函数句柄</h4><p>函数句柄给人的感觉就好像是函数指针通过 <code>mysin=@sin</code> 此时就可以直接使用<code>mysin</code> 函数来当作<code>sin</code> 函数使用。</p><h4 id="匿名函数">匿名函数</h4><p>匿名函数就像是函数句柄的一种特殊的方式高级用法。此时可以是函数的表达式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f=@(x)(x.^<span class="hljs-number">2</span>)<br>f(<span class="hljs-number">2</span>) <span class="hljs-comment">%4</span><br></code></pre></td></tr></table></figure><h4 id="编程技巧">编程技巧</h4><p>利用 <code>tic</code> <code>toc</code> 可以用来求函数运行的时间。</p><hr><h3 id="1-3基于simulink的仿真">1.3基于simulink的仿真</h3><p>使用图形化的系统模块对研究对象进行描述， 每个模块像实验室中的每一台仪器一样，可以根据需要进行不同的组合以达到不同的研究目的。</p><hr><h2 id="第二、三章：计算机视觉与数字图像处理基础-基于系统对象编程">第二、三章：计算机视觉与数字图像处理基础+基于系统对象编程</h2><p>因为第二章是讲解了一些基础知识，感觉纯纯看完基础知识再看第三章的编程部分就没忘光了（主要也是一直看基础知识太无聊了根本看不下去！！看一小时睡三小时！！）所以想着两章一起做个记录。</p><hr><h3 id="视频的边缘检测">视频的边缘检测</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 对视频进行边缘检测</span><br>clc;<br>clear all;<br>close all;<br>hvideosrc = vision.VideoFileReader(<span class="hljs-string">&#x27;vipmen.avi&#x27;</span>, <span class="hljs-string">&#x27;ImageColorSpace&#x27;</span>, <span class="hljs-string">&#x27;Intensity&#x27;</span>);<br><br>WindowSize = [<span class="hljs-number">190</span> <span class="hljs-number">150</span>];<br>hvideoorig = vision.VideoPlayer(<span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Original&#x27;</span>);<br>hvideoorig.Position = [<span class="hljs-number">10</span> hvideoorig.Position(<span class="hljs-number">2</span>) WindowSize];<br>hvideoedge = vision.VideoPlayer(<span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Edges&#x27;</span>);<br>hvideoedge.Position = [<span class="hljs-number">210</span> hvideoorig.Position(<span class="hljs-number">2</span>) WindowSize];<br><br><span class="hljs-keyword">while</span> ~isDone(hvideosrc)<br>    frame = step(hvideosrc);<br>    <br>    <span class="hljs-comment">% 手动进行边缘检测</span><br>    edges = edge(frame, <span class="hljs-string">&#x27;Prewitt&#x27;</span>, <span class="hljs-number">15</span>/<span class="hljs-number">256</span>); <span class="hljs-comment">% 可以尝试不同的方法和阈值</span><br>    <br>    step(hvideoorig, frame);<br>    step(hvideoedge, edges);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="灰度直方图">灰度直方图</h3><p>图像的灰度是在RGB空间内， <code>R=G=B</code> 的时候 ，图像显示是灰度的，其中求将一幅彩色的图片转化为灰度图片可以采用以下这三种方式：</p><p>最大值法 ：选取<code>R、G、B</code>中的值最大的一个值，同时将最大值赋给<code>R、G、B</code> 保证三者的值相同。</p><p>平均值法：选取<code> R、G、B</code> 的均值来当作<code>R、G、B</code> 三者的值。</p><p>加权法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clc; <br>clear all; <br>close all;<br><br>I = rgb2gray(imread(<span class="hljs-string">&#x27;PeppersRGB.bmp&#x27;</span>));<br>imshow(I);<br><br><span class="hljs-comment">% 将图像转换为单精度数据类型</span><br>img = im2single(I);<br><br><span class="hljs-comment">% 计算直方图</span><br>hist_values = imhist(img);<br><br><span class="hljs-comment">% 绘制直方图</span><br><span class="hljs-built_in">figure</span><br>bar(hist_values, <span class="hljs-string">&#x27;hist&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;灰度级别&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;像素数&#x27;</span>);<br>title(<span class="hljs-string">&#x27;图像的灰度直方图&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="色彩空间">色彩空间</h3><h3 id="缩放变换">缩放变换</h3><h3 id="平移变换">平移变换</h3><h3 id="旋转变换">旋转变换</h3><h3 id="傅里叶变换">傅里叶变换</h3><h3 id="余弦变换">余弦变换</h3><h3 id="图像的腐蚀和膨胀">图像的腐蚀和膨胀</h3><h3 id="图像的开运算、闭运算">图像的开运算、闭运算</h3><h3 id="图像的中值滤波">图像的中值滤波</h3><h3 id="图像的角点检测">图像的角点检测</h3><h3 id="图像的边缘检测">图像的边缘检测</h3>]]></content>
    
    
    <categories>
      
      <category>CV</category>
      
    </categories>
    
    
    <tags>
      
      <tag>record</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Self_introduction</title>
    <link href="/blog.github.io/2023/09/20/Self-introduction/"/>
    <url>/blog.github.io/2023/09/20/Self-introduction/</url>
    
    <content type="html"><![CDATA[<h1 style="color :#4682B4; ">自我介绍</h1><h2 style="color :#00BFFF;">一：兴趣爱好</h2><h3 style="color :#32CD32;">1：听歌：流行、爵士、雷鬼、摇滚。</h3><p>最近偏爱的歌曲是《kiss  me kiss me》</p><p><img src="https://img1.imgtp.com/2023/09/22/X6USNOoj.png" alt="blog1.png"></p><p>最近偏爱的歌手是爱谬</p><p>百度百科的链接为 ：<a href="https://baike.baidu.com/item/%E7%88%B1%E7%BC%AA">爱缪_百度百科 (baidu.com)</a></p><p>除此之外大概就是喜欢睡觉、喜欢熬夜，闲着没事玩两把扫雷，其余大概就没有了。</p><h2 style="color :#00BFFF;"> 二：成就？</h2><p>大概就是高数下册满分、美赛依靠队友获得了H奖，纯靠自己的话感觉S都困难 。</p><p>除了这些感觉在专业上，貌似没什么值得拿出手的成就了。自己感觉自己的专业能力真的是差的一批，但是好像目前除了努力也没有什么方法能改变现状。可谓是上不如学长学姐，下不如学弟学妹，中不如同级。</p><p>感觉自己缺少的东西包括数学知识不太扎实、算法一塌糊涂、编程能力也差得一批。</p><p>如果要说自己对哪类方向是感兴趣的，以前大概对底层有点兴趣（因为好像薪资高一点），但是现在被计组狠狠的打击了一下，感觉图像处理也很有意思，但是貌似自己的专业技能离做研究还差远了…</p><p>希望自己能在大三这一年增强一些专业技能和数学方法吧。</p><h2 style="color :#00BFFF;"> 三：未来规划</h2><p>关于未来到底干什么这件事是想过很多的，既想找到一个安稳的生活，比如考公，也想过一些不太安稳的比如直接就业。现在谈规划感觉还是有一种操之过急的感觉。</p><p>如果有可能的话，大概会去读研究生，找一个好一点的高校，之后再去就业，赚够了就去找个地方学临床医学（梦想！），过个十几年去当医生。</p><p>如果没可能的话，大概会直接去就业，干个几年被优化，之后再去小一点的地方继续干，干了几年再被优化…。</p><p>每种生活都有每种生活的有趣性吧。</p>]]></content>
    
    
    <categories>
      
      <category>SoftWare engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HomeWork</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/blog.github.io/2023/09/20/hello-world/"/>
    <url>/blog.github.io/2023/09/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Default</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
